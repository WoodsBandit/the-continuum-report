<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Continuum | The Continuum Report</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&family=Source+Sans+3:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --void: #0a0a0b;
            --deep: #12101a;
            --mystic: #2d2445;
            --gold: #c9a227;
            --gold-dim: rgba(201, 162, 39, 0.4);
            --gold-glow: rgba(201, 162, 39, 0.6);
            --smoke: #9a9a9a;
            --mist: #c4c4c4;
            --pure: #f5f5f5;
            --purple: #8b6fc0;
            --purple-dim: rgba(139, 111, 192, 0.3);

            --color-person: #c9a227;
            --color-organization: #8b6fc0;
            --color-case: #60a5fa;
            --color-location: #4ade80;
        }

        html, body {
            font-family: 'Source Sans 3', sans-serif;
            background: var(--void);
            color: var(--mist);
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* LOADING STATE */
        #loadingOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        #loadingOverlay.hidden { opacity: 0; pointer-events: none; }
        .loading-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            letter-spacing: 0.3em;
            margin-bottom: 2rem;
        }
        .loading-spinner {
            width: 50px; height: 50px;
            border: 2px solid var(--purple-dim);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-status {
            margin-top: 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--smoke);
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* HEADER */
        header {
            position: fixed;
            top: 0; left: 0; right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.5rem;
            background: rgba(10, 10, 11, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--gold-dim);
            z-index: 1000;  /* Above transition overlay */
        }
        .logo {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            letter-spacing: 0.2em;
            color: var(--gold);
            text-decoration: none;
        }
        .search-container { position: relative; width: 300px; }
        #searchInput {
            width: 100%;
            padding: 0.5rem 1rem 0.5rem 2.5rem;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 20px;
            color: var(--pure);
            font-size: 0.9rem;
        }
        #searchInput:focus { outline: none; border-color: var(--gold); }
        #searchInput::placeholder { color: var(--smoke); }
        .search-icon {
            position: absolute;
            left: 0.75rem; top: 50%;
            transform: translateY(-50%);
            color: var(--smoke);
            width: 18px; height: 18px;
        }
        .header-stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--smoke);
        }
        .header-stats span { color: var(--gold); }

        /* GRAPH */
        #graphContainer {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(45, 36, 69, 0.1) 0%, transparent 70%);
        }
        #graphSvg { width: 100%; height: 100%; cursor: grab; }
        #graphSvg:active { cursor: grabbing; }
        .link { fill: none; transition: stroke 0.3s, stroke-width 0.3s, opacity 0.3s; }
        .link.highlighted { stroke: var(--gold) !important; }
        .link.dimmed { opacity: 0.1; }
        .node { cursor: pointer; transition: opacity 0.3s; }
        .node.dimmed { opacity: 0.15; }
        .node-circle { fill: var(--deep); stroke-width: 2; transition: all 0.3s; }
        .node.active .node-circle { stroke-width: 3; filter: drop-shadow(0 0 10px var(--gold-glow)); }
        .node.pinned .node-circle { stroke-dasharray: 4 2; }
        .node.pinned .node-label::after { content: ' ðŸ“Œ'; font-size: 9px; }
        .node-label {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 11px; fill: var(--mist);
            text-anchor: middle; pointer-events: none;
            transition: fill 0.3s, font-size 0.3s;
        }
        .node.active .node-label { fill: var(--pure); font-size: 13px; font-weight: 500; }
        .node.highlighted .node-label { fill: var(--pure); }
        .node-type-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px; fill: var(--smoke);
            text-anchor: middle; text-transform: uppercase;
        }

        /* DETAIL PANEL */
        #detailPanel {
            position: fixed;
            right: -420px; top: 60px;
            width: 400px;
            max-height: calc(100vh - 80px);
            background: rgba(18, 16, 26, 0.98);
            border: 1px solid var(--gold-dim);
            border-right: none;
            border-radius: 12px 0 0 12px;
            overflow: hidden;
            transition: right 0.3s ease;
            z-index: 200;
        }
        #detailPanel.active { right: 0; }
        .detail-header {
            padding: 1.25rem;
            background: rgba(201, 162, 39, 0.1);
            border-bottom: 1px solid var(--gold-dim);
        }
        .detail-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .detail-title {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            color: var(--pure);
            line-height: 1.3;
        }
        .detail-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--smoke);
            margin-top: 0.5rem;
            line-height: 1.4;
        }
        .detail-close {
            position: absolute;
            top: 1rem; right: 1rem;
            width: 32px; height: 32px;
            background: rgba(139, 111, 192, 0.3);
            border: none; border-radius: 50%;
            color: var(--mist); font-size: 1.2rem;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .detail-close:hover { background: var(--gold); color: var(--void); }
        .detail-content {
            padding: 1.25rem;
            overflow-y: auto;
            max-height: calc(100vh - 240px);
        }
        .detail-content p { margin-bottom: 1rem; line-height: 1.7; font-size: 0.95rem; }
        .detail-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--purple-dim);
        }
        .detail-section h4 {
            font-family: 'Cinzel', serif;
            font-size: 0.85rem;
            color: var(--gold);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }
        .connection-list { list-style: none; }
        .connection-item {
            padding: 0.6rem 0;
            border-bottom: 1px solid rgba(139, 111, 192, 0.1);
            cursor: pointer;
            transition: background 0.2s;
            margin: 0 -1.25rem;
            padding-left: 1.25rem;
            padding-right: 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .connection-item:hover { background: rgba(201, 162, 39, 0.1); }
        .connection-item:last-child { border-bottom: none; }
        .connection-name { color: var(--pure); font-weight: 500; }
        .connection-meta { display: flex; align-items: center; gap: 0.75rem; }
        .connection-type { font-size: 0.65rem; color: var(--smoke); text-transform: uppercase; }
        .connection-evidence {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .connection-evidence.documented {
            background: rgba(201, 162, 39, 0.25);
            color: var(--gold);
        }
        .connection-evidence.referenced {
            background: rgba(139, 111, 192, 0.25);
            color: var(--purple);
        }
        .connection-evidence.associated {
            background: rgba(154, 154, 154, 0.2);
            color: var(--smoke);
        }
        .source-list { list-style: none; }
        .source-item {
            padding: 0.5rem 0;
            font-size: 0.85rem;
            border-bottom: 1px solid rgba(139, 111, 192, 0.1);
            cursor: pointer;
            transition: background 0.2s;
            margin: 0 -1.25rem;
            padding-left: 1.25rem;
            padding-right: 1.25rem;
        }
        .source-item:hover { background: rgba(201, 162, 39, 0.1); }
        .source-item:last-child { border-bottom: none; }
        .source-ecf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--gold);
        }
        .source-desc { color: var(--smoke); font-size: 0.8rem; }

        /* ACTION BUTTONS */
        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
            margin-right: 0.5rem;
            padding: 0.6rem 1.2rem;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid var(--gold-dim);
            border-radius: 6px;
            color: var(--gold);
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.85rem;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        .action-btn:hover { background: var(--gold); color: var(--void); }
        .action-btn svg { width: 16px; height: 16px; }

        /* BRIEF VIEWER MODAL */
        #briefViewer {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 11, 0.98);
            z-index: 500;
            display: none;
            flex-direction: column;
        }
        #briefViewer.active { display: flex; }
        .brief-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid var(--gold-dim);
            flex-shrink: 0;
        }
        .brief-header-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }
        .brief-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brief-back-btn:hover { background: var(--purple); color: var(--pure); }
        .brief-title-bar {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold);
        }
        .brief-nav {
            display: flex;
            gap: 0.5rem;
        }
        .brief-nav-btn {
            padding: 0.5rem 1rem;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brief-nav-btn:hover { border-color: var(--gold); color: var(--gold); }
        .brief-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .brief-container {
            flex: 1;
            overflow-y: auto;
            padding: 2rem 4rem;
        }
        .brief-content {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(18, 16, 26, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 12px;
            padding: 3rem;
        }
        .brief-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: var(--smoke);
        }
        .brief-loading .loading-spinner { width: 40px; height: 40px; margin-bottom: 1rem; }

        /* BRIEF MARKDOWN STYLES */
        .brief-content h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gold-dim);
        }
        .brief-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.4rem;
            color: var(--pure);
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--purple-dim);
        }
        .brief-content h3 {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gold);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .brief-content h4 {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--mist);
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .brief-content p {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--mist);
            margin-bottom: 1.25rem;
        }
        .brief-content blockquote {
            margin: 1.5rem 0;
            padding: 1.25rem 1.5rem;
            background: rgba(201, 162, 39, 0.08);
            border-left: 3px solid var(--gold);
            border-radius: 0 8px 8px 0;
        }
        .brief-content blockquote p {
            font-style: italic;
            margin-bottom: 0.5rem;
        }
        .brief-content blockquote p:last-child { margin-bottom: 0; }
        .brief-content ul, .brief-content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }
        .brief-content li {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--mist);
            margin-bottom: 0.5rem;
        }
        .brief-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.95rem;
        }
        .brief-content th, .brief-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--purple-dim);
            text-align: left;
        }
        .brief-content th {
            background: rgba(139, 111, 192, 0.2);
            font-weight: 600;
            color: var(--pure);
        }
        .brief-content td { color: var(--mist); }
        .brief-content tr:nth-child(even) td { background: rgba(45, 36, 69, 0.2); }
        .brief-content strong { color: var(--pure); font-weight: 600; }
        .brief-content em { font-style: italic; }
        .brief-content hr {
            border: none;
            height: 1px;
            background: var(--purple-dim);
            margin: 2rem 0;
        }
        .brief-content code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            background: rgba(45, 36, 69, 0.6);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--gold);
        }
        .brief-content a {
            color: var(--gold);
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        .brief-content a:hover { color: var(--pure); }

        /* Entity links in brief content */
        .entity-mention {
            color: var(--gold);
            cursor: pointer;
            border-bottom: 1px dotted var(--gold-dim);
            transition: all 0.2s;
        }
        .entity-mention:hover {
            background: rgba(201, 162, 39, 0.2);
            border-bottom-color: var(--gold);
        }

        /* PDF VIEWER MODAL */
        #pdfViewer {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 11, 0.98);
            z-index: 600;
            display: none;
            flex-direction: column;
        }
        #pdfViewer.active { display: flex; }
        .pdf-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid var(--gold-dim);
            flex-shrink: 0;
            gap: 1rem;
        }
        .pdf-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            min-width: 0;
        }
        .pdf-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--gold);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pdf-header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .pdf-close-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-close-btn:hover { background: var(--purple); color: var(--pure); }
        .pdf-container {
            flex: 1;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        .pdf-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .pdf-canvas-wrapper {
            flex: 1;
            width: 100%;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            display: flex;
            justify-content: center;
            padding: 1rem;
        }
        .pdf-canvas-wrapper canvas {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            /* Width and height set via JS for crisp retina rendering */
        }
        .pdf-nav-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(18, 16, 26, 0.95);
            border-top: 1px solid var(--purple-dim);
            flex-shrink: 0;
        }
        .pdf-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 8px;
            color: var(--mist);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-nav-btn:hover:not(:disabled) {
            background: var(--purple);
            color: var(--pure);
            border-color: var(--purple);
        }
        .pdf-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .pdf-page-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--mist);
            min-width: 80px;
            text-align: center;
        }
        .pdf-zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
            padding-left: 1rem;
            border-left: 1px solid var(--purple-dim);
        }
        .pdf-zoom-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-zoom-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
        }
        .pdf-download-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--gold);
            border: none;
            border-radius: 6px;
            color: var(--void);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }
        .pdf-download-link:hover { background: var(--pure); }
        .pdf-placeholder {
            text-align: center;
            color: var(--smoke);
            padding: 2rem;
        }
        .pdf-placeholder h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
        }
        .pdf-placeholder p { margin-bottom: 1rem; }
        .pdf-download-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--gold);
            border: none;
            border-radius: 6px;
            color: var(--void);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
        }
        .pdf-download-btn:hover { background: var(--pure); }
        .pacer-verify {
            display: inline-block;
            padding: 0.6rem 1rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid var(--gold);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.9rem;
        }
        .pacer-verify em { color: var(--gold); }
        .pdf-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--smoke);
        }
        .pdf-loading .loading-spinner {
            width: 40px;
            height: 40px;
            margin-bottom: 1rem;
        }
        .pdf-error {
            text-align: center;
            padding: 2rem;
            color: var(--smoke);
        }
        .pdf-error h3 {
            color: #ef4444;
            margin-bottom: 1rem;
        }

        /* Mobile PDF viewer optimizations */
        @media (max-width: 768px) {
            .pdf-header {
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
            }
            .pdf-header-left {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            .pdf-title {
                font-size: 0.8rem;
            }
            .pdf-header-controls {
                width: 100%;
                justify-content: space-between;
            }
            .pdf-close-btn span {
                display: none;
            }
            .pdf-nav-controls {
                padding: 0.75rem;
                gap: 0.75rem;
            }
            .pdf-nav-btn {
                width: 48px;
                height: 48px;
                font-size: 1.3rem;
            }
            .pdf-zoom-controls {
                display: none;
            }
            .pdf-canvas-wrapper {
                padding: 0.5rem;
            }
        }

        /* ECF CLICKABLE LINKS */
        .ecf-link {
            color: var(--gold);
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
            transition: all 0.2s ease;
            padding: 0 0.15em;
            border-radius: 2px;
        }
        .ecf-link:hover {
            color: var(--pure);
            background: rgba(201, 162, 39, 0.2);
            text-decoration-style: solid;
        }
        .ecf-table-row:hover {
            background: rgba(201, 162, 39, 0.1) !important;
        }
        .ecf-table-row td {
            transition: background 0.2s ease;
        }

        /* LEGEND */
        #legend {
            position: fixed;
            bottom: 1.5rem; left: 1.5rem;
            display: flex;
            gap: 1.25rem;
            padding: 0.75rem 1rem;
            background: rgba(18, 16, 26, 0.9);
            border: 1px solid var(--purple-dim);
            border-radius: 8px;
            z-index: 50;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            color: var(--smoke);
            cursor: pointer;
            transition: color 0.2s;
        }
        .legend-item:hover { color: var(--pure); }
        .legend-item.active { color: var(--pure); }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        /* CONTROLS */
        #controls {
            position: fixed;
            bottom: 1.5rem; right: 1.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 50;
        }
        .control-btn {
            width: 40px; height: 40px;
            background: rgba(18, 16, 26, 0.9);
            border: 1px solid var(--purple-dim);
            border-radius: 8px;
            color: var(--mist);
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .control-btn:hover { border-color: var(--gold); color: var(--gold); }

        /* TOOLTIP */
        #tooltip {
            position: fixed;
            padding: 0.6rem 0.85rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--gold);
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--pure);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 280px;
        }
        #tooltip.visible { opacity: 1; }
        #tooltip .tooltip-type {
            font-size: 0.65rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.2rem;
        }
        #tooltip .tooltip-name { font-weight: 500; margin-bottom: 0.3rem; }
        #tooltip .tooltip-connections { font-size: 0.75rem; color: var(--smoke); }

        /* LAYER INDICATOR (Breadcrumb) */
        #layerIndicator {
            position: fixed;
            top: 52px;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1.5rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid rgba(139, 111, 192, 0.2);
            z-index: 999;  /* Above transition overlay, below header */
            backdrop-filter: blur(10px);
        }
        .layer-crumb {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .layer-crumb:hover {
            color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }
        .layer-crumb.active {
            color: var(--gold);
            font-weight: 600;
            background: rgba(201, 162, 39, 0.15);
        }
        .layer-crumb.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        .layer-separator {
            color: rgba(139, 111, 192, 0.5);
            font-size: 0.8rem;
        }
        .layer-count {
            margin-left: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--smoke);
        }
        .layer-count span { color: var(--gold); }

        /* TRANSITION OVERLAY - positioned to not cover header/indicators */
        #transitionOverlay {
            position: fixed;
            top: 85px;  /* Below header and layer indicator */
            left: 0;
            right: 60px;  /* Leave space for level indicator */
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(45, 36, 69, 0.92), rgba(10, 10, 11, 0.97));
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 200;  /* Below header (1000) and indicators */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #transitionOverlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        .transition-content {
            text-align: center;
        }
        .transition-text {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.2rem;
            margin-top: 1rem;
            letter-spacing: 0.1em;
        }

        /* NETWORK CLUSTER NODES (for zoomed-out view) */
        .network-cluster {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .network-cluster:hover {
            filter: brightness(1.2);
        }
        .network-cluster-bg {
            fill: var(--deep);
            stroke-width: 2;
            rx: 16;
            transition: all 0.3s ease;
        }
        .network-cluster:hover .network-cluster-bg {
            stroke-width: 3;
            filter: drop-shadow(0 0 15px var(--gold-glow));
        }
        .network-cluster-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            fill: var(--pure);
            text-anchor: middle;
            font-weight: 500;
        }
        .network-cluster-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            fill: var(--gold);
            text-anchor: middle;
        }
        .network-cluster-status {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 10px;
            fill: var(--smoke);
            text-anchor: middle;
        }
        .network-cluster-center {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: var(--gold);
            text-anchor: middle;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .network-cluster.placeholder .network-cluster-bg {
            stroke-dasharray: 6 4;
            opacity: 0.6;
        }
        .network-cluster.placeholder .network-cluster-title {
            fill: var(--smoke);
        }

        /* LAYER NODES (for macro view) */
        .layer-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .layer-node:hover {
            filter: brightness(1.2);
        }
        .layer-node-bg {
            fill: var(--void);
            stroke-width: 3;
            transition: all 0.3s ease;
        }
        .layer-node:hover .layer-node-bg {
            stroke-width: 4;
            filter: drop-shadow(0 0 20px var(--gold-glow));
        }
        .layer-node-title {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            fill: var(--pure);
            text-anchor: middle;
            font-weight: 600;
            letter-spacing: 0.05em;
        }
        .layer-node-verse {
            font-family: 'Cormorant Garamond', serif;
            font-size: 11px;
            fill: var(--gold);
            text-anchor: middle;
            font-style: italic;
        }
        .layer-node-desc {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 10px;
            fill: var(--smoke);
            text-anchor: middle;
        }

        /* DOCUMENT NODES (for zoomed-in document view) */
        .document-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .document-node:hover {
            filter: brightness(1.2);
        }
        .document-node-bg {
            fill: rgba(26, 16, 37, 0.95);
            stroke: rgba(139, 111, 192, 0.6);
            stroke-width: 1;
            stroke-dasharray: 4 2;
            rx: 8;
            transition: all 0.3s ease;
        }
        .document-node:hover .document-node-bg {
            stroke: var(--gold);
            stroke-width: 2;
            filter: drop-shadow(0 0 8px var(--gold-glow));
        }
        .document-node-icon {
            font-size: 1.5rem;
            fill: var(--gold);
            text-anchor: middle;
        }
        .document-node-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: var(--pure);
            text-anchor: middle;
        }
        .document-node-desc {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 8px;
            fill: var(--smoke);
            text-anchor: middle;
        }
        .document-connection {
            stroke: rgba(139, 111, 192, 0.4);
            stroke-dasharray: 4 4;
            stroke-width: 1;
        }

        /* LEVEL INDICATOR BADGE */
        .level-badge {
            position: fixed;
            bottom: 80px;
            left: 1.5rem;
            padding: 0.5rem 1rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--gold-dim);
            border-radius: 8px;
            z-index: 50;
            display: none;
        }
        .level-badge.visible { display: block; }
        .level-badge-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .level-badge-value {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            color: var(--gold);
            margin-top: 0.25rem;
        }

        /* ZOOM HINT */
        .zoom-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem 1rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--purple-dim);
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .zoom-hint.visible { opacity: 1; }
        .zoom-hint .hint-key {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            background: rgba(139, 111, 192, 0.3);
            border-radius: 4px;
            margin: 0 0.25rem;
            color: var(--gold);
        }

        /* NODE TRANSITIONS */
        .node-entering {
            opacity: 0;
            transform: scale(0.8);
        }
        .node-entered {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .node-exiting {
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        /* LEVEL INDICATOR (Side Panel) */
        #levelIndicator {
            position: fixed;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            z-index: 998;  /* Above transition overlay */
            padding: 1rem 0.5rem;
            background: rgba(18, 16, 26, 0.9);
            border: 1px solid rgba(139, 111, 192, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        .level-track {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }
        .level-node {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .level-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(139, 111, 192, 0.4);
            border: 2px solid rgba(139, 111, 192, 0.6);
            transition: all 0.3s ease;
        }
        .level-node:hover .level-dot {
            background: rgba(139, 111, 192, 0.7);
            transform: scale(1.1);
        }
        .level-node.active .level-dot {
            background: var(--gold);
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
        }
        .level-node.visited .level-dot {
            background: rgba(201, 162, 39, 0.5);
            border-color: rgba(201, 162, 39, 0.7);
        }
        .level-node.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .level-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.3s ease;
            position: absolute;
            right: 100%;
            margin-right: 0.5rem;
        }
        .level-node:hover .level-label,
        .level-node.active .level-label {
            opacity: 1;
            transform: translateX(0);
        }
        .level-node.active .level-label {
            color: var(--gold);
            font-weight: 600;
        }
        .level-connector {
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, rgba(139, 111, 192, 0.4), rgba(139, 111, 192, 0.2));
        }
        .level-connector.active {
            background: linear-gradient(to bottom, var(--gold), rgba(201, 162, 39, 0.3));
        }
        .zoom-percentage {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(139, 111, 192, 0.2);
        }
        @keyframes levelPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .level-node.transitioning .level-dot {
            animation: levelPulse 0.5s ease;
        }

        /* ZOOM WARNING BANNER */
        #zoomWarning {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 1rem 1.5rem;
            background: rgba(18, 16, 26, 0.98);
            border: 2px solid var(--gold);
            border-radius: 12px;
            z-index: 997;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
            min-width: 280px;
        }
        #zoomWarning.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }
        #zoomWarning.bounce {
            animation: warningBounce 0.4s ease;
        }
        @keyframes warningBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            25% { transform: translateX(-50%) translateY(-8px); }
            50% { transform: translateX(-50%) translateY(0); }
            75% { transform: translateX(-50%) translateY(-4px); }
        }
        .warning-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .warning-icon {
            font-size: 1.5rem;
            animation: warningPulse 1s ease infinite;
        }
        @keyframes warningPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        .warning-text {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.9rem;
            color: var(--pure);
        }
        .warning-direction {
            color: var(--gold);
            font-weight: 600;
        }
        .warning-target {
            color: var(--gold);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .warning-hint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        .warning-progress {
            width: 100%;
            height: 4px;
            background: rgba(139, 111, 192, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .warning-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--gold), #f4d03f);
            border-radius: 2px;
            transition: width 0.15s ease;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            header { padding: 0.5rem 1rem; }
            .logo { font-size: 0.8rem; }
            .search-container { width: 180px; }
            .header-stats { display: none; }
            #detailPanel { width: 100%; right: -100%; border-radius: 0; }
            #legend {
                bottom: auto; top: 100px; left: 0.5rem;
                flex-wrap: wrap; gap: 0.75rem; padding: 0.5rem 0.75rem;
            }
            .legend-item { font-size: 0.65rem; }
            #controls { bottom: 1rem; right: 1rem; }
            .brief-container { padding: 1rem; }
            .brief-content { padding: 1.5rem; }
            .brief-header { padding: 1rem; }
            /* Layer indicator mobile */
            #layerIndicator {
                top: 48px;
                padding: 0.4rem 0.75rem;
                gap: 0.25rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .layer-crumb {
                font-size: 0.6rem;
                padding: 0.2rem 0.4rem;
                white-space: nowrap;
            }
            .layer-separator { font-size: 0.7rem; }
            .zoom-hint { display: none; }
            /* Level indicator mobile: horizontal at bottom */
            #levelIndicator {
                right: auto;
                left: 50%;
                top: auto;
                bottom: 70px;
                transform: translateX(-50%);
                flex-direction: row;
                padding: 0.5rem 1rem;
            }
            .level-track {
                flex-direction: row;
                gap: 0;
            }
            .level-connector {
                width: 20px;
                height: 2px;
            }
            .level-label {
                position: absolute;
                top: 100%;
                right: auto;
                left: 50%;
                transform: translateX(-50%) translateY(5px);
                margin-right: 0;
                margin-top: 0.3rem;
            }
            .level-node:hover .level-label,
            .level-node.active .level-label {
                transform: translateX(-50%) translateY(0);
            }
            .zoom-percentage {
                margin-top: 0;
                margin-left: 0.75rem;
                padding-top: 0;
                padding-left: 0.75rem;
                border-top: none;
                border-left: 1px solid rgba(139, 111, 192, 0.2);
            }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">
        <div class="loading-title">THE CONTINUUM</div>
        <div class="loading-spinner"></div>
        <div class="loading-status" id="loadingStatus">Loading knowledge graph...</div>
    </div>

    <header>
        <a href="/" class="logo">TCR</a>
        <div class="search-container">
            <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
            </svg>
            <input type="text" id="searchInput" placeholder="Filter entities...">
        </div>
        <div class="header-stats">
            <span id="entityCount">0</span> entities Â· <span id="connectionCount">0</span> connections
        </div>
    </header>

    <!-- Layer Indicator (Breadcrumb Navigation) -->
    <div id="layerIndicator">
        <span class="layer-crumb" data-level="macro" title="View all layers">THE CONTINUUM</span>
        <span class="layer-separator">â€º</span>
        <span class="layer-crumb" data-level="networks" title="View networks">EPSTEIN NETWORK</span>
        <span class="layer-separator">â€º</span>
        <span class="layer-crumb active" data-level="entities" title="View entities">15 Entities</span>
    </div>

    <!-- Transition Overlay -->
    <div id="transitionOverlay">
        <div class="transition-content">
            <div class="loading-spinner"></div>
            <div class="transition-text">Transitioning...</div>
        </div>
    </div>

    <div id="graphContainer">
        <svg id="graphSvg"></svg>
    </div>

    <div id="detailPanel">
        <button class="detail-close" id="closeDetail">&times;</button>
        <div class="detail-header">
            <div class="detail-type" id="detailType">Person</div>
            <h2 class="detail-title" id="detailTitle">Entity Name</h2>
            <div class="detail-status" id="detailStatus"></div>
        </div>
        <div class="detail-content" id="detailContent"></div>
    </div>

    <!-- Brief Viewer Modal -->
    <div id="briefViewer">
        <div class="brief-header">
            <div class="brief-header-left">
                <button class="brief-back-btn" id="closeBrief">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Back to Graph
                </button>
                <span class="brief-title-bar" id="briefTitleBar">Analytical Brief</span>
            </div>
            <div class="brief-nav">
                <button class="brief-nav-btn" id="briefPrev" disabled>Previous</button>
                <button class="brief-nav-btn" id="briefNext" disabled>Next</button>
            </div>
        </div>
        <div class="brief-container">
            <div class="brief-content" id="briefContent">
                <div class="brief-loading">
                    <div class="loading-spinner"></div>
                    <p>Loading analytical brief...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- PDF Viewer Modal -->
    <div id="pdfViewer">
        <div class="pdf-header">
            <div class="pdf-header-left">
                <span class="pdf-title" id="pdfTitle">Document Viewer</span>
            </div>
            <div class="pdf-header-controls">
                <a href="#" class="pdf-download-link" id="pdfDownloadLink" target="_blank" style="display: none;">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                    </svg>
                    Download
                </a>
                <button class="pdf-close-btn" id="closePdf">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                    <span>Close</span>
                </button>
            </div>
        </div>
        <div class="pdf-container" id="pdfContainer">
            <div class="pdf-placeholder">
                <h3>Document Viewer</h3>
                <p>PDF viewer will appear here when documents are available.</p>
            </div>
        </div>
        <div class="pdf-nav-controls" id="pdfNavControls" style="display: none;">
            <button class="pdf-nav-btn" id="pdfPrevPage" title="Previous Page">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 18l-6-6 6-6"/>
                </svg>
            </button>
            <span class="pdf-page-info" id="pdfPageInfo">1 / 1</span>
            <button class="pdf-nav-btn" id="pdfNextPage" title="Next Page">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 18l6-6-6-6"/>
                </svg>
            </button>
            <div class="pdf-zoom-controls">
                <button class="pdf-zoom-btn" id="pdfZoomOut" title="Zoom Out">âˆ’</button>
                <button class="pdf-zoom-btn" id="pdfZoomIn" title="Zoom In">+</button>
            </div>
        </div>
    </div>

    <div id="legend">
        <div class="legend-item active" data-type="all">
            <div class="legend-dot" style="background: var(--pure)"></div>
            All
        </div>
        <div class="legend-item" data-type="person">
            <div class="legend-dot" style="background: var(--color-person)"></div>
            Person
        </div>
        <div class="legend-item" data-type="organization">
            <div class="legend-dot" style="background: var(--color-organization)"></div>
            Organization
        </div>
        <div class="legend-item" data-type="case">
            <div class="legend-dot" style="background: var(--color-case)"></div>
            Case
        </div>
    </div>

    <div id="controls">
        <button class="control-btn" id="zoomIn" title="Zoom In">+</button>
        <button class="control-btn" id="zoomOut" title="Zoom Out">&minus;</button>
        <button class="control-btn" id="resetView" title="Reset View">&#x27F2;</button>
    </div>

    <!-- Zoom Hint -->
    <div class="zoom-hint" id="zoomHint">
        <span class="hint-key">1</span> Macro
        <span class="hint-key">2</span> Networks
        <span class="hint-key">3</span> Entities
        <span class="hint-key">4</span> Documents
    </div>

    <!-- Zoom Warning Banner -->
    <div id="zoomWarning">
        <div class="warning-content">
            <div class="warning-icon">âš </div>
            <div class="warning-text">
                <span class="warning-direction">Zoom out</span> to view <span class="warning-target">Networks</span>
            </div>
        </div>
        <div class="warning-hint">Continue zooming to proceed</div>
        <div class="warning-progress">
            <div class="warning-progress-bar"></div>
        </div>
    </div>

    <!-- Level Indicator (Side Panel) -->
    <div id="levelIndicator">
        <div class="level-track">
            <div class="level-node" data-level="macro">
                <div class="level-dot"></div>
                <div class="level-label">MACRO</div>
            </div>
            <div class="level-connector"></div>
            <div class="level-node" data-level="networks">
                <div class="level-dot"></div>
                <div class="level-label">NETWORKS</div>
            </div>
            <div class="level-connector"></div>
            <div class="level-node active" data-level="entities">
                <div class="level-dot"></div>
                <div class="level-label">ENTITIES</div>
            </div>
            <div class="level-connector"></div>
            <div class="level-node" data-level="documents">
                <div class="level-dot"></div>
                <div class="level-label">SOURCES</div>
            </div>
        </div>
        <div class="zoom-percentage" id="zoomPercentage">100%</div>
    </div>

    <div id="tooltip">
        <div class="tooltip-type"></div>
        <div class="tooltip-name"></div>
        <div class="tooltip-connections"></div>
    </div>

    <script>
        // Configure marked.js
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        // ============================================================
        // DATA LOADING
        // ============================================================
        // Global sources index for PDF availability checking
        let sourcesIndex = null;

        async function loadData() {
            const statusEl = document.getElementById('loadingStatus');
            try {
                statusEl.textContent = 'Fetching entities...';
                const entitiesRes = await fetch('/data/entities.json');
                if (!entitiesRes.ok) throw new Error('Failed to load entities.json');
                const entitiesData = await entitiesRes.json();

                statusEl.textContent = 'Fetching connections...';
                const connectionsRes = await fetch('/data/connections.json');
                if (!connectionsRes.ok) throw new Error('Failed to load connections.json');
                const connectionsData = await connectionsRes.json();

                // Load sources index for PDF availability
                statusEl.textContent = 'Fetching sources index...';
                try {
                    const sourcesRes = await fetch('/sources/index.json');
                    if (sourcesRes.ok) {
                        sourcesIndex = await sourcesRes.json();
                    }
                } catch (e) {
                    console.warn('Sources index not available:', e);
                }

                statusEl.textContent = 'Building graph...';
                return {
                    entities: entitiesData.entities,
                    connections: connectionsData.connections
                };
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }

        // ============================================================
        // BRIEF VIEWER
        // ============================================================
        const BriefViewer = {
            currentEntity: null,
            entityList: [],
            currentIndex: -1,

            async open(entity) {
                this.currentEntity = entity;
                this.currentIndex = this.entityList.findIndex(e => e.id === entity.id);
                this.updateNavButtons();

                const viewer = document.getElementById('briefViewer');
                const content = document.getElementById('briefContent');
                const titleBar = document.getElementById('briefTitleBar');

                titleBar.textContent = entity.name;
                content.innerHTML = `
                    <div class="brief-loading">
                        <div class="loading-spinner"></div>
                        <p>Loading analytical brief...</p>
                    </div>
                `;
                viewer.classList.add('active');

                try {
                    const briefPath = `/briefs/${entity.brief_file}`;
                    const response = await fetch(briefPath);

                    if (!response.ok) {
                        throw new Error(`Brief not found: ${briefPath}`);
                    }

                    const markdown = await response.text();
                    const html = this.renderMarkdown(markdown);
                    content.innerHTML = html;

                    // Add click handlers for entity mentions
                    this.linkifyEntityMentions(content);

                } catch (error) {
                    console.error('Error loading brief:', error);
                    content.innerHTML = `
                        <div style="text-align: center; padding: 3rem;">
                            <h2 style="color: var(--gold); margin-bottom: 1rem;">Brief Not Available</h2>
                            <p style="color: var(--smoke); margin-bottom: 1.5rem;">
                                The analytical brief for ${entity.name} could not be loaded.
                            </p>
                            <p style="color: var(--smoke); font-size: 0.9rem;">
                                Expected location: /briefs/${entity.brief_file}
                            </p>
                        </div>
                    `;
                }
            },

            renderMarkdown(markdown) {
                return marked.parse(markdown);
            },

            linkifyEntityMentions(container) {
                // Get all known entity names
                const entityNames = {};
                this.entityList.forEach(e => {
                    entityNames[e.name.toLowerCase()] = e;
                    // Also add common variations
                    const nameParts = e.name.split(' ');
                    if (nameParts.length > 1) {
                        entityNames[nameParts[nameParts.length - 1].toLowerCase()] = e;
                    }
                });

                // Linkify ECF references throughout the brief
                this.linkifyECFReferences(container);
            },

            // Convert ECF references into clickable links
            linkifyECFReferences(container) {
                // Regex patterns to match various ECF reference formats
                const ecfPatterns = [
                    /ECF\s+(?:Doc(?:ument)?\.?\s*)?(\d{3,4}(?:-\d{1,3})?)/gi,
                    /ECF\s+#?\s*(\d{3,4}(?:-\d{1,3})?)/gi,
                    /Document\s+(\d{3,4}-\d{1,3})/gi,
                    /Doc\.\s*(\d{3,4}-\d{1,3})/gi
                ];

                // Combined pattern for all formats
                const combinedPattern = /(?:ECF\s+(?:Doc(?:ument)?\.?\s*)?#?\s*|Document\s+|Doc\.\s*)(\d{3,4}(?:-\d{1,3})?)/gi;

                // Process all text nodes in the container
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    if (combinedPattern.test(node.textContent)) {
                        nodesToProcess.push(node);
                    }
                    combinedPattern.lastIndex = 0; // Reset regex
                }

                // Process each text node
                nodesToProcess.forEach(textNode => {
                    const text = textNode.textContent;
                    const parent = textNode.parentNode;

                    // Skip if already inside a link or ECF link
                    if (parent.tagName === 'A' || parent.classList?.contains('ecf-link')) {
                        return;
                    }

                    // Create a temporary container
                    const span = document.createElement('span');
                    let lastIndex = 0;
                    let match;
                    let hasMatches = false;

                    // Reset and find all matches
                    combinedPattern.lastIndex = 0;
                    const matches = [];
                    while ((match = combinedPattern.exec(text)) !== null) {
                        matches.push({
                            fullMatch: match[0],
                            ecf: match[1],
                            index: match.index
                        });
                    }

                    if (matches.length === 0) return;

                    matches.forEach(m => {
                        hasMatches = true;
                        // Add text before the match
                        if (m.index > lastIndex) {
                            span.appendChild(document.createTextNode(text.slice(lastIndex, m.index)));
                        }

                        // Create clickable ECF link
                        const ecfLink = document.createElement('span');
                        ecfLink.className = 'ecf-link';
                        ecfLink.textContent = m.fullMatch;
                        ecfLink.dataset.ecf = m.ecf;
                        ecfLink.title = `View ECF ${m.ecf}`;
                        ecfLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.openECFDocument(m.ecf);
                        });

                        span.appendChild(ecfLink);
                        lastIndex = m.index + m.fullMatch.length;
                    });

                    // Add remaining text
                    if (lastIndex < text.length) {
                        span.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }

                    if (hasMatches) {
                        parent.replaceChild(span, textNode);
                    }
                });

                // Also make table cells with ECF numbers clickable
                this.linkifySourceTables(container);
            },

            // Make source document tables clickable
            linkifySourceTables(container) {
                const tables = container.querySelectorAll('table');
                tables.forEach(table => {
                    const rows = table.querySelectorAll('tbody tr, tr');
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 2) {
                            const firstCell = cells[0];
                            const text = firstCell.textContent.trim();

                            // Check if first cell contains an ECF reference
                            // Handles: 1320-9, 1329-0_1, 1328-44, etc.
                            const ecfMatch = text.match(/^(\d{3,4}(?:-\d{1,3})?(?:_\d+)?)$/);
                            if (ecfMatch) {
                                // Normalize ECF: remove underscore suffix for lookup
                                const ecfRaw = ecfMatch[1];
                                const ecf = ecfRaw.replace(/_\d+$/, '');

                                // Make the entire row clickable
                                row.classList.add('ecf-table-row');
                                row.style.cursor = 'pointer';
                                row.title = `View ECF ${ecf}`;
                                row.addEventListener('click', (e) => {
                                    if (e.target.tagName !== 'A') {
                                        e.preventDefault();
                                        this.openECFDocument(ecf);
                                    }
                                });

                                // Also wrap the ECF number in the cell
                                if (!firstCell.querySelector('.ecf-link')) {
                                    firstCell.innerHTML = `<span class="ecf-link" data-ecf="${ecf}">${text}</span>`;
                                }
                            }
                        }
                    });
                });
            },

            // Open ECF document in PDF viewer
            openECFDocument(ecf) {
                // Get description from current entity's sources if available
                let description = 'Court Document';
                if (this.currentEntity && this.currentEntity.sources) {
                    const sourceDoc = this.currentEntity.sources.find(s => s.ecf === ecf);
                    if (sourceDoc) {
                        description = sourceDoc.description || 'Court Document';
                    }
                }

                // Open the PDF viewer with this ECF
                PDFViewer.open({
                    ecf: ecf,
                    description: description
                });
            },

            close() {
                document.getElementById('briefViewer').classList.remove('active');
                this.currentEntity = null;
            },

            updateNavButtons() {
                const prevBtn = document.getElementById('briefPrev');
                const nextBtn = document.getElementById('briefNext');

                prevBtn.disabled = this.currentIndex <= 0;
                nextBtn.disabled = this.currentIndex >= this.entityList.length - 1;
            },

            prev() {
                if (this.currentIndex > 0) {
                    const prevEntity = this.entityList[this.currentIndex - 1];
                    if (prevEntity.brief_file) {
                        this.open(prevEntity);
                    }
                }
            },

            next() {
                if (this.currentIndex < this.entityList.length - 1) {
                    const nextEntity = this.entityList[this.currentIndex + 1];
                    if (nextEntity.brief_file) {
                        this.open(nextEntity);
                    }
                }
            }
        };

        // ============================================================
        // PDF VIEWER (with pdf.js for mobile support)
        // ============================================================
        const PDFViewer = {
            // State
            pdfDoc: null,
            currentPage: 1,
            totalPages: 0,
            scale: 1.5,
            currentPdfPath: null,
            rendering: false,

            // Case folder mappings - most briefs cite Giuffre v. Maxwell
            caseInfo: {
                'giuffre-v-maxwell': {
                    citation: 'Giuffre v. Maxwell, No. 15-cv-07433-LAP (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                },
                'epstein-sdny': {
                    citation: 'United States v. Epstein, No. 19-cr-00490 (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                },
                'maxwell-criminal': {
                    citation: 'United States v. Maxwell, No. 20-cr-00330 (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                }
            },

            init() {
                // Set up pdf.js worker
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }

                // Bind navigation controls
                document.getElementById('pdfPrevPage').addEventListener('click', () => this.prevPage());
                document.getElementById('pdfNextPage').addEventListener('click', () => this.nextPage());
                document.getElementById('pdfZoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('pdfZoomOut').addEventListener('click', () => this.zoomOut());
            },

            // Check if PDF is available in sources index
            isPdfAvailable(ecf) {
                if (!sourcesIndex || !sourcesIndex.cases) return { available: false, caseFolder: null };

                // Search all cases for this ECF number
                for (const [folder, caseData] of Object.entries(sourcesIndex.cases)) {
                    const doc = caseData.documents.find(d => d.ecf === ecf);
                    if (doc && doc.available) {
                        return { available: true, caseFolder: folder, filename: doc.filename };
                    }
                }
                return { available: false, caseFolder: 'giuffre-v-maxwell' }; // Default case for PACER link
            },

            // Check if on mobile device
            isMobile() {
                return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            async open(source) {
                const viewer = document.getElementById('pdfViewer');
                const container = document.getElementById('pdfContainer');
                const title = document.getElementById('pdfTitle');
                const navControls = document.getElementById('pdfNavControls');
                const downloadLink = document.getElementById('pdfDownloadLink');

                title.textContent = `ECF ${source.ecf} - ${source.description}`;

                // Reset state
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.scale = this.isMobile() ? 1.0 : 1.5;

                // Check PDF availability from pre-loaded index
                const pdfStatus = this.isPdfAvailable(source.ecf);
                const caseFolder = pdfStatus.caseFolder || 'giuffre-v-maxwell';
                const caseData = this.caseInfo[caseFolder];

                if (pdfStatus.available) {
                    const pdfPath = `/sources/${caseFolder}/${pdfStatus.filename}`;
                    this.currentPdfPath = pdfPath;

                    // Show download link
                    downloadLink.href = pdfPath;
                    downloadLink.style.display = 'flex';

                    // Show loading state
                    container.innerHTML = `
                        <div class="pdf-loading">
                            <div class="loading-spinner"></div>
                            <p>Loading document...</p>
                        </div>
                    `;
                    navControls.style.display = 'none';

                    viewer.classList.add('active');

                    // Try to load with pdf.js
                    await this.loadPDF(pdfPath, container, source, caseData);
                } else {
                    // PDF not available - show PACER verification link
                    downloadLink.style.display = 'none';
                    navControls.style.display = 'none';

                    container.innerHTML = `
                        <div class="pdf-placeholder">
                            <h3>ECF Document ${source.ecf}</h3>
                            <p><strong>${source.description}</strong></p>
                            <p style="margin-top: 1.5rem; font-size: 0.95rem; color: var(--smoke);">
                                This document is not yet available in our archive.
                            </p>
                            <p style="margin-top: 1.5rem;">
                                <span class="pacer-verify">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 0.5rem;">
                                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                                    </svg>
                                    Verify via PACER: <em>${caseData.citation}</em>
                                </span>
                            </p>
                            <p style="margin-top: 1.5rem; font-size: 0.85rem;">
                                <a href="${caseData.pacer}" target="_blank" rel="noopener" style="color: var(--gold);">
                                    Access PACER â†’
                                </a>
                            </p>
                        </div>
                    `;

                    viewer.classList.add('active');
                }
            },

            async loadPDF(pdfPath, container, source, caseData) {
                // Check if pdf.js is available
                if (typeof pdfjsLib === 'undefined') {
                    // Fallback to iframe for desktop, download for mobile
                    this.showFallback(pdfPath, container, source, caseData);
                    return;
                }

                try {
                    // Load the PDF document
                    const loadingTask = pdfjsLib.getDocument(pdfPath);
                    this.pdfDoc = await loadingTask.promise;
                    this.totalPages = this.pdfDoc.numPages;

                    // Set up the canvas container
                    container.innerHTML = `<div class="pdf-canvas-wrapper" id="pdfCanvasWrapper"><canvas id="pdfCanvas"></canvas></div>`;

                    // Show navigation controls
                    document.getElementById('pdfNavControls').style.display = 'flex';
                    this.updatePageInfo();

                    // Render the first page
                    await this.renderPage(this.currentPage);

                    // Add touch/pinch zoom support for mobile
                    this.setupTouchZoom();

                } catch (error) {
                    console.error('Error loading PDF with pdf.js:', error);
                    // Fallback
                    this.showFallback(pdfPath, container, source, caseData);
                }
            },

            showFallback(pdfPath, container, source, caseData) {
                const navControls = document.getElementById('pdfNavControls');
                navControls.style.display = 'none';

                if (this.isMobile()) {
                    // On mobile, show download button prominently
                    container.innerHTML = `
                        <div class="pdf-placeholder">
                            <h3>ECF Document ${source.ecf}</h3>
                            <p><strong>${source.description}</strong></p>
                            <p style="margin-top: 1rem; font-size: 0.9rem;">
                                Source: <em>${caseData.citation}</em>
                            </p>
                            <p style="margin-top: 1.5rem; color: var(--smoke);">
                                For the best viewing experience on mobile, open this document in your device's PDF viewer.
                            </p>
                            <p style="margin-top: 1.5rem;">
                                <a href="${pdfPath}" target="_blank" class="pdf-download-btn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                                    </svg>
                                    Open in PDF Viewer
                                </a>
                            </p>
                        </div>
                    `;
                } else {
                    // On desktop, use iframe
                    container.innerHTML = `<iframe src="${pdfPath}" title="ECF ${source.ecf}"></iframe>`;
                }
            },

            async renderPage(pageNum) {
                if (!this.pdfDoc || this.rendering) return;

                this.rendering = true;
                const canvas = document.getElementById('pdfCanvas');
                const ctx = canvas.getContext('2d');

                try {
                    const page = await this.pdfDoc.getPage(pageNum);

                    // Get device pixel ratio for crisp rendering on retina/high-DPI displays
                    const pixelRatio = window.devicePixelRatio || 1;

                    // Calculate base scale based on container width for mobile
                    let baseScale = this.scale;
                    if (this.isMobile()) {
                        const wrapper = document.getElementById('pdfCanvasWrapper');
                        const wrapperWidth = wrapper.clientWidth - 20; // Account for padding
                        const baseViewport = page.getViewport({ scale: 1 });
                        baseScale = Math.min(wrapperWidth / baseViewport.width, this.scale);
                    }

                    // Create viewport at base scale for CSS dimensions
                    const cssViewport = page.getViewport({ scale: baseScale });

                    // Create viewport at higher resolution for crisp rendering
                    const renderScale = baseScale * pixelRatio;
                    const renderViewport = page.getViewport({ scale: renderScale });

                    // Set canvas dimensions at high resolution
                    canvas.width = renderViewport.width;
                    canvas.height = renderViewport.height;

                    // Set CSS dimensions at logical size (this creates crisp rendering)
                    canvas.style.width = cssViewport.width + 'px';
                    canvas.style.height = cssViewport.height + 'px';

                    const renderContext = {
                        canvasContext: ctx,
                        viewport: renderViewport
                    };

                    await page.render(renderContext).promise;
                    this.updatePageInfo();

                } catch (error) {
                    console.error('Error rendering page:', error);
                }

                this.rendering = false;
            },

            updatePageInfo() {
                const pageInfo = document.getElementById('pdfPageInfo');
                const prevBtn = document.getElementById('pdfPrevPage');
                const nextBtn = document.getElementById('pdfNextPage');

                pageInfo.textContent = `${this.currentPage} / ${this.totalPages}`;
                prevBtn.disabled = this.currentPage <= 1;
                nextBtn.disabled = this.currentPage >= this.totalPages;
            },

            prevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderPage(this.currentPage);
                    // Scroll to top of canvas
                    document.getElementById('pdfCanvasWrapper')?.scrollTo(0, 0);
                }
            },

            nextPage() {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    this.renderPage(this.currentPage);
                    // Scroll to top of canvas
                    document.getElementById('pdfCanvasWrapper')?.scrollTo(0, 0);
                }
            },

            zoomIn() {
                this.scale = Math.min(this.scale + 0.25, 3);
                this.renderPage(this.currentPage);
            },

            zoomOut() {
                this.scale = Math.max(this.scale - 0.25, 0.5);
                this.renderPage(this.currentPage);
            },

            setupTouchZoom() {
                const wrapper = document.getElementById('pdfCanvasWrapper');
                if (!wrapper) return;

                let initialDistance = 0;
                let initialScale = this.scale;

                wrapper.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        initialDistance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        initialScale = this.scale;
                    }
                }, { passive: true });

                wrapper.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && initialDistance > 0) {
                        const currentDistance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        const ratio = currentDistance / initialDistance;
                        const newScale = Math.min(Math.max(initialScale * ratio, 0.5), 3);

                        if (Math.abs(newScale - this.scale) > 0.1) {
                            this.scale = newScale;
                            this.renderPage(this.currentPage);
                        }
                    }
                }, { passive: true });

                wrapper.addEventListener('touchend', () => {
                    initialDistance = 0;
                }, { passive: true });
            },

            close() {
                const viewer = document.getElementById('pdfViewer');
                const navControls = document.getElementById('pdfNavControls');
                const downloadLink = document.getElementById('pdfDownloadLink');

                viewer.classList.remove('active');
                navControls.style.display = 'none';
                downloadLink.style.display = 'none';

                // Clean up
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.currentPdfPath = null;
            }
        };

        // ============================================================
        // HIERARCHY MANAGER (Hierarchical Zoom)
        // ============================================================
        const HierarchyManager = {
            data: null,
            currentLevel: 'macro',
            previousLevel: null,
            focusedNetwork: 'epstein-network',
            focusedEntity: null,
            transitioning: false,
            transitionCooldown: false,
            lastTransitionTime: 0,
            lastZoomScale: 1.0,

            // Warning/bounce-stop state
            pendingTransition: null,        // { from: 'entities', to: 'networks', direction: 'out' }
            warningShownAt: 0,
            bounceStopActive: false,

            // Bidirectional zoom thresholds - ADJUSTED for better readability
            thresholds: {
                // Zooming OUT thresholds (scale decreasing) - triggers when going BELOW
                ENTITIES_TO_NETWORKS: 0.22,    // Below this â†’ show network clusters
                NETWORKS_TO_MACRO: 0.35,       // Below this â†’ show macro layer view
                DOCUMENTS_TO_ENTITIES: 1.0,    // Below this when in documents â†’ return to entities

                // Zooming IN thresholds (scale increasing) - triggers when going ABOVE
                MACRO_TO_NETWORKS: 2.0,        // Above this when in macro â†’ show networks (zoom in to see networks)
                NETWORKS_TO_ENTITIES: 1.4,     // Above this when in networks â†’ show entities
                ENTITIES_TO_DOCUMENTS: 2.5     // Above this when focused on entity â†’ show documents
            },

            // WARNING thresholds - bounce-stop triggers here, actual transition requires continued zoom
            warningThresholds: {
                // Zooming OUT warnings
                ENTITIES_TO_NETWORKS: 0.28,    // Warning at 28%, transition at 22%
                NETWORKS_TO_MACRO: 0.42,       // Warning at 42%, transition at 35%
                DOCUMENTS_TO_ENTITIES: 1.15,   // Warning at 115%, transition at 100%

                // Zooming IN warnings
                MACRO_TO_NETWORKS: 1.7,        // Warning at 170%, transition at 200%
                NETWORKS_TO_ENTITIES: 1.2,     // Warning at 120%, transition at 140%
                ENTITIES_TO_DOCUMENTS: 2.2     // Warning at 220%, transition at 250%
            },

            // Safe zoom values - middle of each level's range to prevent re-triggers
            safeZoom: {
                macro: 1.0,       // Full page view for macro
                networks: 0.65,   // Increased to be in middle of 0.15-1.4 range
                entities: 1.0,
                documents: 3.0
            },

            async init() {
                try {
                    const response = await fetch('/data/hierarchy.json');
                    if (response.ok) {
                        this.data = await response.json();
                        console.log('Hierarchy data loaded:', this.data);
                    } else {
                        console.warn('Hierarchy data not available, using defaults');
                        this.data = this.getDefaultHierarchy();
                    }
                } catch (e) {
                    console.warn('Error loading hierarchy:', e);
                    this.data = this.getDefaultHierarchy();
                }
                this.updateLayerIndicator();
                this.updateSideLevelIndicator();
                this.updateZoomPercentage(1.0);
            },

            getDefaultHierarchy() {
                return {
                    layers: [{ id: 'intelligence', name: 'Intelligence Networks', children: ['epstein-network'] }],
                    networks: [{
                        id: 'epstein-network',
                        name: 'Epstein Network',
                        parent: 'intelligence',
                        entityCount: 15,
                        connectionCount: 78,
                        entities: [],
                        color: '#c9a227'
                    }],
                    zoomConfig: {
                        thresholds: this.thresholds
                    }
                };
            },

            // Check zoom scale and determine if level transition needed (BIDIRECTIONAL with BOUNCE-STOP)
            checkZoomLevel(scale, focusedNode = null) {
                // Don't check during active transition or cooldown
                if (this.transitioning || this.transitionCooldown) {
                    this.lastZoomScale = scale;
                    this.updateZoomPercentage(scale);
                    return false;
                }

                // Prevent rapid re-triggers (500ms minimum between transitions)
                const now = Date.now();
                if (now - this.lastTransitionTime < 500) {
                    this.lastZoomScale = scale;
                    this.updateZoomPercentage(scale);
                    return false;
                }

                const zoomingIn = scale > this.lastZoomScale;
                const zoomingOut = scale < this.lastZoomScale;
                this.lastZoomScale = scale;

                // Update zoom percentage display
                this.updateZoomPercentage(scale);

                // Determine current transition context
                let potentialTransition = null;
                let direction = null;
                let warningThreshold = null;
                let actualThreshold = null;
                let inWarningZone = false;
                let pastThreshold = false;

                // ZOOM OUT CHECKS
                if (this.currentLevel === 'documents') {
                    warningThreshold = this.warningThresholds.DOCUMENTS_TO_ENTITIES;
                    actualThreshold = this.thresholds.DOCUMENTS_TO_ENTITIES;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'documents', to: 'entities' };
                        pastThreshold = scale < actualThreshold;
                    }
                } else if (this.currentLevel === 'entities') {
                    warningThreshold = this.warningThresholds.ENTITIES_TO_NETWORKS;
                    actualThreshold = this.thresholds.ENTITIES_TO_NETWORKS;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'entities', to: 'networks' };
                        pastThreshold = scale < actualThreshold;
                    }
                    // Also check for zoom IN to documents
                    if (!inWarningZone && focusedNode) {
                        warningThreshold = this.warningThresholds.ENTITIES_TO_DOCUMENTS;
                        actualThreshold = this.thresholds.ENTITIES_TO_DOCUMENTS;
                        if (scale > warningThreshold) {
                            inWarningZone = true;
                            direction = 'in';
                            potentialTransition = { from: 'entities', to: 'documents', focusNode: focusedNode };
                            pastThreshold = scale > actualThreshold;
                        }
                    }
                } else if (this.currentLevel === 'networks') {
                    // Check zoom OUT to macro
                    warningThreshold = this.warningThresholds.NETWORKS_TO_MACRO;
                    actualThreshold = this.thresholds.NETWORKS_TO_MACRO;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'networks', to: 'macro' };
                        pastThreshold = scale < actualThreshold;
                    }
                    // Check zoom IN to entities
                    if (!inWarningZone) {
                        warningThreshold = this.warningThresholds.NETWORKS_TO_ENTITIES;
                        actualThreshold = this.thresholds.NETWORKS_TO_ENTITIES;
                        if (scale > warningThreshold) {
                            inWarningZone = true;
                            direction = 'in';
                            potentialTransition = { from: 'networks', to: 'entities' };
                            pastThreshold = scale > actualThreshold;
                        }
                    }
                } else if (this.currentLevel === 'macro') {
                    warningThreshold = this.warningThresholds.MACRO_TO_NETWORKS;
                    actualThreshold = this.thresholds.MACRO_TO_NETWORKS;
                    if (scale > warningThreshold) {
                        inWarningZone = true;
                        direction = 'in';
                        potentialTransition = { from: 'macro', to: 'networks' };
                        pastThreshold = scale > actualThreshold;
                    }
                }

                // Handle warning zone and bounce-stop logic
                if (inWarningZone && potentialTransition) {
                    // Calculate progress through warning zone (0 = just entered, 1 = at threshold)
                    let progress;
                    if (direction === 'out') {
                        // Zooming out: warningThreshold > actualThreshold
                        progress = (warningThreshold - scale) / (warningThreshold - actualThreshold);
                    } else {
                        // Zooming in: warningThreshold < actualThreshold
                        progress = (scale - warningThreshold) / (actualThreshold - warningThreshold);
                    }
                    progress = Math.max(0, Math.min(1, progress));

                    // Show or update warning
                    this.showWarning(direction, potentialTransition.to, progress);
                    this.pendingTransition = potentialTransition;

                    // Check if we should proceed with transition
                    // Require: past threshold AND minimum 300ms in warning zone
                    const timeInWarning = now - this.warningShownAt;
                    if (pastThreshold && timeInWarning > 300) {
                        console.log(`Bounce-stop confirmed: ${potentialTransition.from} â†’ ${potentialTransition.to}`);
                        this.hideWarning();
                        if (potentialTransition.focusNode) {
                            this.focusedEntity = potentialTransition.focusNode;
                        }
                        this.transitionToLevel(potentialTransition.to);
                        return true;
                    }
                } else {
                    // Not in warning zone - hide warning if it was showing
                    if (this.bounceStopActive) {
                        this.hideWarning();
                    }
                }

                return false;  // No transition triggered
            },

            // Update zoom percentage display
            updateZoomPercentage(scale) {
                const el = document.getElementById('zoomPercentage');
                if (el) {
                    el.textContent = Math.round(scale * 100) + '%';
                }
            },

            // Show zoom warning with bounce-stop
            showWarning(direction, targetLevel, progress = 0) {
                const warning = document.getElementById('zoomWarning');
                const directionEl = warning.querySelector('.warning-direction');
                const targetEl = warning.querySelector('.warning-target');
                const progressBar = warning.querySelector('.warning-progress-bar');

                directionEl.textContent = direction === 'out' ? 'Zoom out' : 'Zoom in';
                targetEl.textContent = targetLevel.toUpperCase();

                // Update progress bar (0 to 1)
                if (progressBar) {
                    progressBar.style.width = Math.min(100, progress * 100) + '%';
                }

                if (!warning.classList.contains('active')) {
                    warning.classList.add('active');
                    // Trigger bounce animation
                    warning.classList.add('bounce');
                    setTimeout(() => warning.classList.remove('bounce'), 400);
                    this.warningShownAt = Date.now();
                    this.bounceStopActive = true;
                }
            },

            // Hide zoom warning
            hideWarning() {
                const warning = document.getElementById('zoomWarning');
                if (warning) {
                    warning.classList.remove('active');
                }
                this.pendingTransition = null;
                this.bounceStopActive = false;
            },

            // Update warning progress bar
            updateWarningProgress(progress) {
                const progressBar = document.querySelector('#zoomWarning .warning-progress-bar');
                if (progressBar) {
                    progressBar.style.width = Math.min(100, progress * 100) + '%';
                }
            },

            // Transition between hierarchy levels
            async transitionToLevel(targetLevel) {
                if (this.transitioning || targetLevel === this.currentLevel) return;

                // Lock transitions and enable cooldown
                this.transitioning = true;
                this.transitionCooldown = true;
                this.previousLevel = this.currentLevel;

                console.log(`Transitioning: ${this.currentLevel} â†’ ${targetLevel}`);

                const overlay = document.getElementById('transitionOverlay');
                const transitionText = overlay.querySelector('.transition-text');

                // Add transitioning class to target level node for pulse animation
                const targetNode = document.querySelector(`#levelIndicator .level-node[data-level="${targetLevel}"]`);
                if (targetNode) {
                    targetNode.classList.add('transitioning');
                    setTimeout(() => targetNode.classList.remove('transitioning'), 500);
                }

                // Set transition message based on direction
                if (this.getLevelDepth(targetLevel) < this.getLevelDepth(this.currentLevel)) {
                    transitionText.textContent = 'Ascending...';
                } else {
                    transitionText.textContent = 'Descending...';
                }

                // Show overlay
                overlay.classList.add('active');

                // Fade out current view
                if (Graph.nodeElements) {
                    Graph.nodeElements.transition().duration(200)
                        .style('opacity', 0)
                        .attr('transform', d => `translate(${d.x}, ${d.y}) scale(0.8)`);
                }
                if (Graph.linkElements) {
                    Graph.linkElements.transition().duration(200)
                        .style('opacity', 0);
                }

                await this.sleep(300);

                // Update current level
                this.currentLevel = targetLevel;
                this.updateLayerIndicator();

                // Rebuild view for new level
                await this.rebuildViewForLevel(targetLevel);

                // Set lastZoomScale to SAFE value for new level to prevent re-trigger
                // The render functions handle the actual D3 zoom transform
                const safeZoom = this.safeZoom[targetLevel] || 1.0;
                this.lastZoomScale = safeZoom;
                this.updateZoomPercentage(safeZoom);

                // Hide overlay
                await this.sleep(100);
                overlay.classList.remove('active');

                // Release transition lock and record time
                this.transitioning = false;
                this.lastTransitionTime = Date.now();

                console.log(`Transition complete. Safe zoom set to ${safeZoom}`);

                // Release cooldown after additional delay to prevent re-triggers
                setTimeout(() => {
                    this.transitionCooldown = false;
                    console.log('Transition cooldown released');
                }, 600);
            },

            getLevelDepth(level) {
                const depths = { macro: 0, networks: 1, entities: 2, documents: 3 };
                return depths[level] || 2;
            },

            async rebuildViewForLevel(level) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Clear existing elements
                if (Graph.g) {
                    Graph.g.selectAll('.network-cluster').remove();
                    Graph.g.selectAll('.layer-node').remove();
                    Graph.g.selectAll('.document-node').remove();
                    Graph.g.selectAll('.document-connection').remove();
                }

                switch(level) {
                    case 'macro':
                        await this.renderMacroView();
                        break;
                    case 'networks':
                        await this.renderNetworksView();
                        break;
                    case 'entities':
                        await this.renderEntitiesView();
                        break;
                    case 'documents':
                        await this.renderDocumentsView();
                        break;
                }
            },

            async renderMacroView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Hide entity nodes and links
                if (Graph.nodeElements) Graph.nodeElements.style('display', 'none');
                if (Graph.linkElements) Graph.linkElements.style('display', 'none');

                // Get layers from hierarchy data
                const layers = this.data?.layers?.filter(l => l.level === 1) || [];

                // Create layer nodes
                const layerGroup = Graph.g.append('g').attr('class', 'layer-nodes');

                const centerX = width / 2;
                const centerY = height / 2;

                // Position layers in a circle around center - sized to fill page
                const circleRadius = Math.min(width, height) * 0.32;  // Responsive radius
                layers.forEach((layer, i) => {
                    const angle = (i / layers.length) * Math.PI * 2 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * circleRadius;
                    const y = centerY + Math.sin(angle) * circleRadius;

                    const node = layerGroup.append('g')
                        .attr('class', 'layer-node')
                        .attr('transform', `translate(${x}, ${y})`)
                        .style('opacity', 0)
                        .on('click', () => this.drillIntoLayer(layer.id));

                    node.append('rect')
                        .attr('class', 'layer-node-bg')
                        .attr('width', 180)
                        .attr('height', 90)
                        .attr('x', -90)
                        .attr('y', -45)
                        .attr('rx', 12)
                        .attr('stroke', layer.color || '#c9a227');

                    node.append('text')
                        .attr('class', 'layer-node-title')
                        .attr('y', -8)
                        .text(layer.name);

                    const childCount = layer.children?.length || 0;
                    node.append('text')
                        .attr('class', 'layer-node-desc')
                        .attr('y', 15)
                        .text(`${childCount} network${childCount !== 1 ? 's' : ''}`);

                    // Fade in
                    node.transition().duration(300).delay(i * 50)
                        .style('opacity', 1);
                });

                // Add central "Continuum" node - sized responsively
                const centerRadius = Math.min(width, height) * 0.08;
                const continuum = layerGroup.append('g')
                    .attr('class', 'layer-node continuum-node')
                    .attr('transform', `translate(${centerX}, ${centerY})`)
                    .style('opacity', 0);

                continuum.append('circle')
                    .attr('r', centerRadius)
                    .attr('fill', 'var(--void)')
                    .attr('stroke', 'var(--gold)')
                    .attr('stroke-width', 3);

                continuum.append('text')
                    .attr('class', 'layer-node-title')
                    .attr('y', -8)
                    .attr('fill', 'var(--gold)')
                    .attr('font-size', '14px')
                    .text('THE');

                continuum.append('text')
                    .attr('class', 'layer-node-title')
                    .attr('y', 12)
                    .attr('fill', 'var(--gold)')
                    .attr('font-size', '14px')
                    .text('CONTINUUM');

                continuum.transition().duration(300)
                    .style('opacity', 1);

                // Set zoom to identity (scale 1.0) for macro level - elements already positioned at screen center
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform, d3.zoomIdentity);
                this.lastZoomScale = 1.0;
            },

            async renderNetworksView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Hide entity nodes and links
                if (Graph.nodeElements) Graph.nodeElements.style('display', 'none');
                if (Graph.linkElements) Graph.linkElements.style('display', 'none');

                // Get networks from hierarchy data
                const networks = this.data?.networks || [];

                // Create network cluster nodes
                const networkGroup = Graph.g.append('g').attr('class', 'network-clusters');

                const cols = Math.ceil(Math.sqrt(networks.length));
                const spacing = 220;
                const startX = (width - (cols - 1) * spacing) / 2;
                const startY = height / 2 - 50;

                networks.forEach((network, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;

                    const isPlaceholder = network.placeholder || network.entityCount === 0;

                    const node = networkGroup.append('g')
                        .attr('class', `network-cluster ${isPlaceholder ? 'placeholder' : ''}`)
                        .attr('transform', `translate(${x}, ${y})`)
                        .style('opacity', 0)
                        .on('click', () => {
                            if (!isPlaceholder) {
                                this.drillIntoNetwork(network.id);
                            }
                        })
                        .on('dblclick', () => {
                            if (!isPlaceholder) {
                                this.drillIntoNetwork(network.id);
                            }
                        });

                    node.append('rect')
                        .attr('class', 'network-cluster-bg')
                        .attr('width', 200)
                        .attr('height', 110)
                        .attr('x', -100)
                        .attr('y', -55)
                        .attr('stroke', network.color || '#c9a227');

                    node.append('text')
                        .attr('class', 'network-cluster-title')
                        .attr('y', -20)
                        .text(network.name);

                    // Split stats into two lines to prevent overflow
                    node.append('text')
                        .attr('class', 'network-cluster-count')
                        .attr('y', 5)
                        .text(`${network.entityCount} entities`);

                    node.append('text')
                        .attr('class', 'network-cluster-count')
                        .attr('y', 22)
                        .text(`${network.connectionCount} connections`);

                    node.append('text')
                        .attr('class', 'network-cluster-status')
                        .attr('y', 40)
                        .text(network.status || '');

                    // Add central figure indicator for networks with a defined center
                    if (network.id === 'epstein-network') {
                        node.append('text')
                            .attr('class', 'network-cluster-center')
                            .attr('y', -38)
                            .text('â¬¤ Jeffrey Epstein');
                    }

                    // Fade in
                    node.transition().duration(300).delay(i * 80)
                        .style('opacity', 1);
                });

                // Set zoom to safe value for networks level
                const safeZoom = this.safeZoom.networks;
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform, d3.zoomIdentity.translate(window.innerWidth / 2, window.innerHeight / 2).scale(safeZoom));
            },

            async renderEntitiesView() {
                // Remove any network/layer/document nodes
                Graph.g.selectAll('.network-clusters').remove();
                Graph.g.selectAll('.layer-nodes').remove();
                Graph.g.selectAll('.document-nodes').remove();

                // Show entity nodes and links
                if (Graph.nodeElements) {
                    Graph.nodeElements.style('display', null)
                        .style('opacity', 0)
                        .transition().duration(300)
                        .style('opacity', 1)
                        .attr('transform', d => `translate(${d.x}, ${d.y})`);
                }
                if (Graph.linkElements) {
                    Graph.linkElements.style('display', null)
                        .style('opacity', 0)
                        .transition().duration(300)
                        .style('opacity', d => d.bidirectional || d.type === 'documented' ? 0.7 : 0.4);
                }

                // Set zoom to safe value for entities level and fit the graph
                const safeZoom = this.safeZoom.entities;
                setTimeout(() => {
                    Graph.resetView();
                    // Update lastZoomScale to match after resetView
                    this.lastZoomScale = safeZoom;
                }, 100);
            },

            async renderDocumentsView() {
                if (!this.focusedEntity) {
                    await this.renderEntitiesView();
                    return;
                }

                const entity = this.focusedEntity;
                const sources = entity.sources || [];

                if (sources.length === 0) {
                    await this.renderEntitiesView();
                    return;
                }

                // Dim other nodes
                if (Graph.nodeElements) {
                    Graph.nodeElements.classed('dimmed', d => d.id !== entity.id);
                }
                if (Graph.linkElements) {
                    Graph.linkElements.classed('dimmed', true);
                }

                // Create document nodes around the entity
                const docGroup = Graph.g.append('g').attr('class', 'document-nodes');

                const radius = 150;
                sources.slice(0, 8).forEach((source, i) => {
                    const angle = (i / Math.min(sources.length, 8)) * Math.PI * 2 - Math.PI / 2;
                    const x = entity.x + Math.cos(angle) * radius;
                    const y = entity.y + Math.sin(angle) * radius;

                    // Connection line
                    docGroup.append('line')
                        .attr('class', 'document-connection')
                        .attr('x1', entity.x)
                        .attr('y1', entity.y)
                        .attr('x2', x)
                        .attr('y2', y)
                        .style('opacity', 0)
                        .transition().duration(300).delay(i * 50)
                        .style('opacity', 1);

                    // Document node
                    const node = docGroup.append('g')
                        .attr('class', 'document-node')
                        .attr('transform', `translate(${x}, ${y})`)
                        .style('opacity', 0)
                        .on('click', () => {
                            PDFViewer.open(source);
                        });

                    node.append('rect')
                        .attr('class', 'document-node-bg')
                        .attr('width', 100)
                        .attr('height', 60)
                        .attr('x', -50)
                        .attr('y', -30);

                    node.append('text')
                        .attr('class', 'document-node-icon')
                        .attr('y', -5)
                        .text('ðŸ“„');

                    node.append('text')
                        .attr('class', 'document-node-title')
                        .attr('y', 12)
                        .text(`ECF ${source.ecf}`);

                    const desc = source.description || '';
                    const shortDesc = desc.length > 18 ? desc.substring(0, 16) + '...' : desc;
                    node.append('text')
                        .attr('class', 'document-node-desc')
                        .attr('y', 24)
                        .text(shortDesc);

                    // Fade in
                    node.transition().duration(300).delay(i * 50)
                        .style('opacity', 1);
                });

                // Zoom to center on entity
                const scale = 1.5;
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform,
                        d3.zoomIdentity
                            .translate(window.innerWidth / 2 - entity.x * scale, window.innerHeight / 2 - entity.y * scale)
                            .scale(scale));
            },

            drillIntoLayer(layerId) {
                this.focusedNetwork = null;
                this.transitionToLevel('networks');
            },

            drillIntoNetwork(networkId) {
                this.focusedNetwork = networkId;
                this.focusedEntity = null;
                this.transitionToLevel('entities');
            },

            // Navigate to a specific level from breadcrumb click
            navigateToLevel(level) {
                if (level === this.currentLevel) return;

                // Reset focused items when going up
                if (this.getLevelDepth(level) < this.getLevelDepth(this.currentLevel)) {
                    if (level === 'macro' || level === 'networks') {
                        this.focusedEntity = null;
                    }
                    if (level === 'macro') {
                        this.focusedNetwork = null;
                    }
                }

                this.transitionToLevel(level);
            },

            updateLayerIndicator() {
                // Update breadcrumb indicator
                const indicator = document.getElementById('layerIndicator');
                if (indicator) {
                    const crumbs = indicator.querySelectorAll('.layer-crumb');
                    crumbs.forEach(crumb => {
                        const level = crumb.dataset.level;
                        crumb.classList.toggle('active', level === this.currentLevel);

                        // Update text based on current state
                        if (level === 'networks') {
                            const network = this.data?.networks?.find(n => n.id === this.focusedNetwork);
                            crumb.textContent = network?.name || 'NETWORKS';
                        } else if (level === 'entities') {
                            const network = this.data?.networks?.find(n => n.id === this.focusedNetwork);
                            const count = network?.entityCount || Graph.nodes?.length || 0;
                            crumb.textContent = `${count} Entities`;
                        }
                    });
                }

                // Update side level indicator
                this.updateSideLevelIndicator();
            },

            // Update the side panel level indicator
            updateSideLevelIndicator() {
                const levels = ['macro', 'networks', 'entities', 'documents'];
                const currentIndex = levels.indexOf(this.currentLevel);

                // Update level nodes
                document.querySelectorAll('#levelIndicator .level-node').forEach(node => {
                    const nodeLevel = node.dataset.level;
                    const nodeIndex = levels.indexOf(nodeLevel);

                    node.classList.remove('active', 'visited', 'transitioning');

                    if (nodeLevel === this.currentLevel) {
                        node.classList.add('active');
                    } else if (nodeIndex < currentIndex) {
                        node.classList.add('visited');
                    }

                    // Disable documents level if no entity is focused
                    if (nodeLevel === 'documents') {
                        node.classList.toggle('disabled', !this.focusedEntity);
                    }
                });

                // Update connectors
                document.querySelectorAll('#levelIndicator .level-connector').forEach((conn, i) => {
                    conn.classList.toggle('active', i < currentIndex);
                });
            },

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // ============================================================
        // GRAPH VISUALIZATION
        // ============================================================
        const Graph = {
            svg: null,
            g: null,
            simulation: null,
            nodes: [],
            links: [],
            zoom: null,
            activeNode: null,
            filterType: 'all',

            colors: {
                person: '#c9a227',
                organization: '#8b6fc0',
                case: '#60a5fa',
                location: '#4ade80'
            },

            async init() {
                try {
                    const data = await loadData();
                    this.buildGraph(data);
                    document.getElementById('loadingOverlay').classList.add('hidden');
                } catch (error) {
                    this.showError(error.message);
                }
            },

            buildGraph(data) {
                this.svg = d3.select('#graphSvg');
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.g = this.svg.append('g');

                this.zoom = d3.zoom()
                    .scaleExtent([0.05, 4])  // Allow zooming out further for macro view
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                        // Check if zoom level triggers hierarchy transition (BIDIRECTIONAL for all levels)
                        // Only check if not in transition and not in cooldown
                        if (!HierarchyManager.transitioning && !HierarchyManager.transitionCooldown) {
                            const transitioned = HierarchyManager.checkZoomLevel(event.transform.k, this.activeNode);
                            // If transition was triggered, stop processing further zoom events
                            if (transitioned) {
                                return;
                            }
                        } else {
                            // Still update the zoom percentage display during cooldown
                            HierarchyManager.updateZoomPercentage(event.transform.k);
                        }
                    });
                this.svg.call(this.zoom);

                this.nodes = data.entities.map(e => {
                    const connectionCount = data.connections.filter(
                        c => c.source === e.id || c.target === e.id
                    ).length;
                    return {
                        ...e,
                        radius: this.getRadius(e.type, connectionCount),
                        connectionCount
                    };
                });

                // Store entity list for brief navigation
                BriefViewer.entityList = this.nodes.filter(n => n.brief_file).sort((a, b) =>
                    a.name.localeCompare(b.name)
                );

                this.links = data.connections.map(c => ({
                    source: c.source,
                    target: c.target,
                    strength: c.strength,
                    type: c.type,
                    bidirectional: c.bidirectional,
                    evidence: c.evidence
                }));

                // Pre-calculate stable positions before rendering
                // Run simulation silently for 300 iterations to find equilibrium
                this.simulation = d3.forceSimulation(this.nodes)
                    .force('link', d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => 150 - (d.strength / 3))
                        .strength(d => 0.3 + (d.strength / 200)))
                    .force('charge', d3.forceManyBody()
                        .strength(d => -200 - (d.connectionCount * 20))
                        .distanceMax(500))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide()
                        .radius(d => d.radius + 25)
                        .strength(1)
                        .iterations(3))
                    .stop(); // Don't start automatically

                // Run 300 iterations silently to find stable positions
                for (let i = 0; i < 300; i++) {
                    this.simulation.tick();
                }

                // Now start with very low alpha for minimal movement
                // High decay = settles quickly, low alpha = minimal bouncing
                this.simulation
                    .alpha(0.01)
                    .alphaDecay(0.08)
                    .alphaMin(0.001)
                    .velocityDecay(0.4)
                    .on('tick', () => this.tick())
                    .restart();

                this.linkElements = this.g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(this.links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', d => this.getLinkColor(d))
                    .attr('stroke-width', d => this.getLinkWidth(d))
                    .attr('stroke-opacity', d => d.bidirectional || d.type === 'documented' ? 0.7 : 0.4)
                    .style('display', 'none');  // Hidden initially - start at macro

                this.nodeElements = this.g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('g')
                    .data(this.nodes)
                    .enter()
                    .append('g')
                    .attr('class', 'node')
                    .style('display', 'none')  // Hidden initially - start at macro
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragStart(event, d))
                        .on('drag', (event, d) => this.dragging(event, d))
                        .on('end', (event, d) => this.dragEnd(event, d)))
                    .on('click', (event, d) => this.selectNode(d))
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        this.releaseNode(d);
                    })
                    .on('mouseenter', (event, d) => this.showTooltip(event, d))
                    .on('mouseleave', () => this.hideTooltip());

                this.nodeElements.append('circle')
                    .attr('class', 'node-circle')
                    .attr('r', d => d.radius)
                    .attr('stroke', d => this.colors[d.type] || this.colors.person);

                this.nodeElements.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', d => d.radius + 15)
                    .text(d => this.truncateLabel(d.name));

                this.nodeElements.append('text')
                    .attr('class', 'node-type-indicator')
                    .attr('dy', 4)
                    .text(d => this.getTypeIcon(d.type));

                document.getElementById('entityCount').textContent = this.nodes.length;
                document.getElementById('connectionCount').textContent = this.links.length;

                // Start at macro level - will be rendered after HierarchyManager initializes
                setTimeout(() => {
                    if (HierarchyManager.data && HierarchyManager.currentLevel === 'macro') {
                        HierarchyManager.renderMacroView();
                    } else {
                        this.resetView();
                    }
                }, 600);
            },

            showError(message) {
                document.getElementById('loadingOverlay').innerHTML = `
                    <div style="text-align: center; padding: 2rem; max-width: 400px;">
                        <h3 style="color: #ef4444; margin-bottom: 1rem;">Failed to Load Data</h3>
                        <p style="color: var(--smoke);">${message}</p>
                    </div>
                `;
            },

            getRadius(type, connectionCount) {
                const baseRadii = { person: 22, organization: 20, case: 20, location: 18 };
                return (baseRadii[type] || 20) + Math.min(connectionCount, 10);
            },

            getLinkColor(link) {
                // Color based on evidence type
                if (link.bidirectional || link.type === 'documented') {
                    return 'rgba(201, 162, 39, 0.6)'; // Gold - Documented
                }
                if (link.type === 'interpreted' || link.strength >= 50) {
                    return 'rgba(139, 111, 192, 0.5)'; // Purple - Referenced
                }
                return 'rgba(154, 154, 154, 0.4)'; // Gray - Associated
            },

            getLinkWidth(link) {
                // Width based on evidence type
                if (link.bidirectional || link.type === 'documented') {
                    return 2.5; // Documented - thickest
                }
                if (link.type === 'interpreted' || link.strength >= 50) {
                    return 1.5; // Referenced
                }
                return 1; // Associated - thinnest
            },

            getTypeIcon(type) {
                const icons = { person: 'PER', organization: 'ORG', case: 'CASE', location: 'LOC' };
                return icons[type] || '?';
            },

            truncateLabel(name) {
                return name.length > 22 ? name.substring(0, 20) + '...' : name;
            },

            tick() {
                this.linkElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                this.nodeElements
                    .attr('transform', d => `translate(${d.x}, ${d.y})`)
                    .classed('pinned', d => d.userPositioned);
            },

            dragStart(event, d) {
                // Gentle simulation for non-pinned nodes
                if (!event.active) this.simulation.alphaTarget(0.1).restart();
                d.fx = d.x;
                d.fy = d.y;
                d.userPositioned = true;
                d._dragging = true;
            },

            dragging(event, d) {
                d.fx = event.x;
                d.fy = event.y;

                // Push overlapping nodes with cascade effect
                this.pushNodesAway(d, event.x, event.y, d.radius + 50, new Set([d.id]));

                // Very gentle alpha for non-pinned nodes
                this.simulation.alpha(0.05);
            },

            // Recursively push nodes away, handling chain reactions
            pushNodesAway(sourceNode, fromX, fromY, minSeparation, alreadyPushed) {
                const nodesToPush = [];

                this.nodes.forEach(other => {
                    if (alreadyPushed.has(other.id)) return;

                    const dx = other.x - fromX;
                    const dy = other.y - fromY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = minSeparation + other.radius;

                    if (dist < minDist && dist > 0) {
                        // Calculate push direction (away from source)
                        const pushDist = minDist - dist + 5; // +5 for a little extra clearance
                        const pushX = (dx / dist) * pushDist;
                        const pushY = (dy / dist) * pushDist;

                        // Move the other node
                        other.x += pushX;
                        other.y += pushY;

                        // If it's pinned, update its pinned position too
                        if (other.userPositioned) {
                            other.fx = other.x;
                            other.fy = other.y;
                        }

                        // Track this node for cascade check
                        nodesToPush.push(other);
                        alreadyPushed.add(other.id);
                    }
                });

                // Cascade: each pushed node may need to push others
                nodesToPush.forEach(pushed => {
                    this.pushNodesAway(pushed, pushed.x, pushed.y, pushed.radius + 25, alreadyPushed);
                });
            },

            dragEnd(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                d._dragging = false;
                // Node stays pinned where user placed it
            },

            // Double-click to release a node from its fixed position
            releaseNode(d) {
                d.fx = null;
                d.fy = null;
                d.userPositioned = false;
                // Gentle restart - node drifts back naturally without bouncing
                this.simulation.alpha(0.05).restart();
            },

            selectNode(node) {
                this.activeNode = node;
                // Track focused entity for document view
                HierarchyManager.focusedEntity = node;

                const connectedIds = new Set([node.id]);
                const connectionData = {};

                this.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === node.id) {
                        connectedIds.add(targetId);
                        connectionData[targetId] = link;
                    }
                    if (targetId === node.id) {
                        connectedIds.add(sourceId);
                        connectionData[sourceId] = link;
                    }
                });

                this.nodeElements
                    .classed('active', d => d.id === node.id)
                    .classed('highlighted', d => connectedIds.has(d.id) && d.id !== node.id)
                    .classed('dimmed', d => !connectedIds.has(d.id));

                this.linkElements
                    .classed('highlighted', d => {
                        const sid = typeof d.source === 'object' ? d.source.id : d.source;
                        const tid = typeof d.target === 'object' ? d.target.id : d.target;
                        return sid === node.id || tid === node.id;
                    })
                    .classed('dimmed', d => {
                        const sid = typeof d.source === 'object' ? d.source.id : d.source;
                        const tid = typeof d.target === 'object' ? d.target.id : d.target;
                        return sid !== node.id && tid !== node.id;
                    });

                this.showDetail(node, connectedIds, connectionData);
            },

            clearSelection() {
                this.activeNode = null;
                this.nodeElements.classed('active', false).classed('highlighted', false).classed('dimmed', false);
                this.linkElements.classed('highlighted', false).classed('dimmed', false);
                document.getElementById('detailPanel').classList.remove('active');
            },

            showDetail(node, connectedIds, connectionData) {
                const panel = document.getElementById('detailPanel');
                document.getElementById('detailType').textContent = node.type.toUpperCase();
                document.getElementById('detailType').style.color = this.colors[node.type];
                document.getElementById('detailTitle').textContent = node.name;
                document.getElementById('detailStatus').textContent = node.status || '';

                let html = '';

                if (node.summary) {
                    html += `<p>${node.summary}</p>`;
                }

                // Action buttons
                html += '<div class="action-buttons">';
                if (node.brief_file) {
                    html += `
                        <button class="action-btn" onclick="BriefViewer.open(Graph.activeNode)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <line x1="10" y1="9" x2="8" y2="9"/>
                            </svg>
                            View Full Brief
                        </button>
                    `;
                }
                // Add document zoom button if entity has sources
                if (node.sources && node.sources.length > 0) {
                    html += `
                        <button class="action-btn" onclick="HierarchyManager.focusedEntity = Graph.activeNode; HierarchyManager.transitionToLevel('documents')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                                <line x1="11" y1="8" x2="11" y2="14"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                            Zoom to Documents
                        </button>
                    `;
                }
                html += '</div>';

                // Connections
                const connections = this.nodes.filter(n => connectedIds.has(n.id) && n.id !== node.id);
                if (connections.length > 0) {
                    // Sort by evidence quality: documented > referenced > associated
                    connections.sort((a, b) => {
                        const linkA = connectionData[a.id];
                        const linkB = connectionData[b.id];
                        const orderA = linkA?.bidirectional ? 0 : (linkA?.type === 'documented' ? 1 : 2);
                        const orderB = linkB?.bidirectional ? 0 : (linkB?.type === 'documented' ? 1 : 2);
                        return orderA - orderB;
                    });

                    html += `<div class="detail-section">
                        <h4>Connections (${connections.length})</h4>
                        <ul class="connection-list">`;

                    connections.forEach(conn => {
                        const link = connectionData[conn.id];
                        // Determine evidence label based on connection data
                        let evidenceLabel, evidenceClass;
                        if (link?.bidirectional || link?.type === 'documented') {
                            evidenceLabel = 'Documented';
                            evidenceClass = 'documented';
                        } else if (link?.type === 'interpreted' || link?.strength >= 50) {
                            evidenceLabel = 'Referenced';
                            evidenceClass = 'referenced';
                        } else {
                            evidenceLabel = 'Associated';
                            evidenceClass = 'associated';
                        }

                        html += `<li class="connection-item" data-entity="${conn.id}">
                            <div>
                                <div class="connection-name">${conn.name}</div>
                                <div class="connection-type" style="color: ${this.colors[conn.type]}">${conn.type}</div>
                            </div>
                            <div class="connection-meta">
                                <span class="connection-evidence ${evidenceClass}">${evidenceLabel}</span>
                            </div>
                        </li>`;
                    });
                    html += '</ul></div>';
                }

                // Source documents
                if (node.sources && node.sources.length > 0) {
                    html += `<div class="detail-section">
                        <h4>Source Documents (${node.sources.length})</h4>
                        <ul class="source-list">`;

                    node.sources.slice(0, 10).forEach((source, i) => {
                        html += `<li class="source-item" data-source-index="${i}">
                            <span class="source-ecf">ECF ${source.ecf}</span>
                            <span class="source-desc"> - ${source.description}</span>
                        </li>`;
                    });

                    if (node.sources.length > 10) {
                        html += `<li class="source-item" style="color: var(--smoke); cursor: default;">
                            + ${node.sources.length - 10} more documents
                        </li>`;
                    }
                    html += '</ul></div>';
                }

                document.getElementById('detailContent').innerHTML = html;

                // Connection click handlers
                document.querySelectorAll('.connection-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const targetNode = this.nodes.find(n => n.id === item.dataset.entity);
                        if (targetNode) this.selectNode(targetNode);
                    });
                });

                // Source document click handlers
                document.querySelectorAll('.source-item[data-source-index]').forEach(item => {
                    item.addEventListener('click', () => {
                        const idx = parseInt(item.dataset.sourceIndex);
                        if (node.sources && node.sources[idx]) {
                            PDFViewer.open(node.sources[idx]);
                        }
                    });
                });

                panel.classList.add('active');

                // Hide tooltip when detail panel opens (fixes mobile overlap)
                this.hideTooltip();
            },

            showTooltip(event, node) {
                // Don't show tooltip if detail panel is open (prevents overlap on mobile)
                if (document.getElementById('detailPanel').classList.contains('active')) {
                    return;
                }

                const tooltip = document.getElementById('tooltip');
                tooltip.querySelector('.tooltip-type').textContent = node.type;
                tooltip.querySelector('.tooltip-type').style.color = this.colors[node.type];
                tooltip.querySelector('.tooltip-name').textContent = node.name;

                let connectionText = `${node.connectionCount} connection${node.connectionCount !== 1 ? 's' : ''}`;
                if (node.userPositioned) {
                    connectionText += ' Â· ðŸ“Œ Pinned (double-click to release)';
                }
                tooltip.querySelector('.tooltip-connections').textContent = connectionText;

                tooltip.style.left = (event.pageX + 15) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
                tooltip.classList.add('visible');
            },

            hideTooltip() {
                document.getElementById('tooltip').classList.remove('visible');
            },

            filterByType(type) {
                this.filterType = type;
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.type === type);
                });

                if (type === 'all') {
                    this.nodeElements.classed('dimmed', false);
                    this.linkElements.classed('dimmed', false);
                    return;
                }

                const matchingIds = new Set();
                this.nodes.forEach(node => {
                    if (node.type === type) matchingIds.add(node.id);
                });

                const expandedIds = new Set(matchingIds);
                this.links.forEach(link => {
                    const sid = typeof link.source === 'object' ? link.source.id : link.source;
                    const tid = typeof link.target === 'object' ? link.target.id : link.target;
                    if (matchingIds.has(sid)) expandedIds.add(tid);
                    if (matchingIds.has(tid)) expandedIds.add(sid);
                });

                this.nodeElements.classed('dimmed', d => !expandedIds.has(d.id));
                this.linkElements.classed('dimmed', d => {
                    const sid = typeof d.source === 'object' ? d.source.id : d.source;
                    const tid = typeof d.target === 'object' ? d.target.id : d.target;
                    return !expandedIds.has(sid) || !expandedIds.has(tid);
                });
            },

            filterNodes(query) {
                const q = query.toLowerCase().trim();
                if (!q) {
                    this.filterByType(this.filterType);
                    return;
                }

                const matchingIds = new Set();
                this.nodes.forEach(node => {
                    if (node.name.toLowerCase().includes(q) ||
                        node.type.toLowerCase().includes(q) ||
                        (node.status && node.status.toLowerCase().includes(q))) {
                        matchingIds.add(node.id);
                    }
                });

                const expandedIds = new Set(matchingIds);
                this.links.forEach(link => {
                    const sid = typeof link.source === 'object' ? link.source.id : link.source;
                    const tid = typeof link.target === 'object' ? link.target.id : link.target;
                    if (matchingIds.has(sid)) expandedIds.add(tid);
                    if (matchingIds.has(tid)) expandedIds.add(sid);
                });

                this.nodeElements.classed('dimmed', d => !expandedIds.has(d.id));
                this.linkElements.classed('dimmed', d => {
                    const sid = typeof d.source === 'object' ? d.source.id : d.source;
                    const tid = typeof d.target === 'object' ? d.target.id : d.target;
                    return !expandedIds.has(sid) || !expandedIds.has(tid);
                });
            },

            zoomIn() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1.3);
            },

            zoomOut() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 0.7);
            },

            resetView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                this.nodes.forEach(node => {
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                    if (node.y < minY) minY = node.y;
                    if (node.y > maxY) maxY = node.y;
                });

                const padding = 100;
                const contentWidth = maxX - minX + padding * 2;
                const contentHeight = maxY - minY + padding * 2;
                const scale = Math.min(width / contentWidth, height / contentHeight, 1.5) * 0.85;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                this.svg.transition().duration(500).call(
                    this.zoom.transform,
                    d3.zoomIdentity.translate(width / 2, height / 2).scale(scale).translate(-centerX, -centerY)
                );
                this.clearSelection();
            }
        };

        // ============================================================
        // EVENT LISTENERS
        // ============================================================
        document.addEventListener('DOMContentLoaded', () => {
            Graph.init();
            PDFViewer.init();
            HierarchyManager.init();

            // Briefly show zoom hint on load
            const zoomHint = document.getElementById('zoomHint');
            if (zoomHint) {
                setTimeout(() => {
                    zoomHint.classList.add('visible');
                    setTimeout(() => {
                        zoomHint.classList.remove('visible');
                    }, 5000);
                }, 2000);
            }

            document.getElementById('searchInput').addEventListener('input', (e) => {
                Graph.filterNodes(e.target.value);
            });

            // Layer indicator (breadcrumb) click handlers
            document.querySelectorAll('.layer-crumb').forEach(crumb => {
                crumb.addEventListener('click', () => {
                    const level = crumb.dataset.level;
                    if (level) {
                        HierarchyManager.navigateToLevel(level);
                    }
                });
            });

            // Side level indicator click handlers
            document.querySelectorAll('#levelIndicator .level-node').forEach(node => {
                node.addEventListener('click', () => {
                    const level = node.dataset.level;
                    if (level && !node.classList.contains('disabled')) {
                        // Don't navigate to documents without a focused entity
                        if (level === 'documents' && !HierarchyManager.focusedEntity) {
                            return;
                        }
                        HierarchyManager.navigateToLevel(level);
                    }
                });
            });

            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    document.getElementById('searchInput').value = '';
                    Graph.filterByType(item.dataset.type);
                });
            });

            document.getElementById('closeDetail').addEventListener('click', () => Graph.clearSelection());
            document.getElementById('zoomIn').addEventListener('click', () => Graph.zoomIn());
            document.getElementById('zoomOut').addEventListener('click', () => Graph.zoomOut());
            document.getElementById('resetView').addEventListener('click', () => Graph.resetView());

            // Brief viewer
            document.getElementById('closeBrief').addEventListener('click', () => BriefViewer.close());
            document.getElementById('briefPrev').addEventListener('click', () => BriefViewer.prev());
            document.getElementById('briefNext').addEventListener('click', () => BriefViewer.next());

            // PDF viewer
            document.getElementById('closePdf').addEventListener('click', () => PDFViewer.close());

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Close modals or navigate hierarchy on Escape
                if (e.key === 'Escape') {
                    if (document.getElementById('pdfViewer').classList.contains('active')) {
                        PDFViewer.close();
                    } else if (document.getElementById('briefViewer').classList.contains('active')) {
                        BriefViewer.close();
                    } else if (HierarchyManager.currentLevel === 'documents') {
                        // Exit document view back to entities
                        HierarchyManager.transitionToLevel('entities');
                    } else if (HierarchyManager.currentLevel === 'networks') {
                        // Exit networks view back to entities
                        HierarchyManager.transitionToLevel('entities');
                    } else if (HierarchyManager.currentLevel === 'macro') {
                        // Exit macro view back to networks
                        HierarchyManager.transitionToLevel('networks');
                    } else {
                        Graph.clearSelection();
                        document.getElementById('searchInput').value = '';
                        Graph.filterByType('all');
                    }
                }

                // PDF navigation
                if (document.getElementById('pdfViewer').classList.contains('active')) {
                    if (e.key === 'ArrowLeft') PDFViewer.prevPage();
                    if (e.key === 'ArrowRight') PDFViewer.nextPage();
                    if (e.key === '+' || e.key === '=') PDFViewer.zoomIn();
                    if (e.key === '-') PDFViewer.zoomOut();
                    return; // Don't process other shortcuts when PDF viewer is open
                }

                // Brief navigation
                if (document.getElementById('briefViewer').classList.contains('active')) {
                    if (e.key === 'ArrowLeft') BriefViewer.prev();
                    if (e.key === 'ArrowRight') BriefViewer.next();
                }

                // Hierarchy level navigation (1-4 keys)
                if (!document.getElementById('briefViewer').classList.contains('active') &&
                    !document.getElementById('pdfViewer').classList.contains('active')) {
                    if (e.key === '1') HierarchyManager.navigateToLevel('macro');
                    if (e.key === '2') HierarchyManager.navigateToLevel('networks');
                    if (e.key === '3') HierarchyManager.navigateToLevel('entities');
                    if (e.key === '4' && HierarchyManager.focusedEntity) {
                        HierarchyManager.transitionToLevel('documents');
                    }
                }

                // Graph zoom (when not in modals)
                if (!document.getElementById('briefViewer').classList.contains('active') &&
                    !document.getElementById('pdfViewer').classList.contains('active')) {
                    if (e.key === '+' || e.key === '=') Graph.zoomIn();
                    if (e.key === '-') Graph.zoomOut();
                    if (e.key === '0') Graph.resetView();

                    // Arrow key level navigation (up/right = go deeper, down/left = go shallower)
                    const levels = ['macro', 'networks', 'entities', 'documents'];
                    const currentIndex = levels.indexOf(HierarchyManager.currentLevel);

                    if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
                        // Go deeper in hierarchy
                        if (currentIndex < levels.length - 1) {
                            const nextLevel = levels[currentIndex + 1];
                            // Don't go to documents without a focused entity
                            if (nextLevel === 'documents' && !HierarchyManager.focusedEntity) {
                                return;
                            }
                            HierarchyManager.navigateToLevel(nextLevel);
                        }
                    }

                    if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
                        // Go shallower in hierarchy
                        if (currentIndex > 0) {
                            HierarchyManager.navigateToLevel(levels[currentIndex - 1]);
                        }
                    }
                }
            });

            window.addEventListener('resize', () => {
                if (Graph.simulation) {
                    Graph.simulation
                        .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                        .alpha(0.3)
                        .restart();
                }
            });
        });
    </script>
</body>
</html>
