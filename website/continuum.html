<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Continuum | The Continuum Report</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&family=Source+Sans+3:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js" integrity="sha512-M7nHCiNUOwFt6Us3r8alutZLm9qMt4s9951uo8jqO4UwJ1hziseL6O3ndFyigx6+LREfZqnhHxYjKRJ8ZQ69DQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js" integrity="sha512-pmjEJQ7CveksANaAKdCJZMig7eAcCFFzE1b5XnlnxdB/vU3AOStJ5SF7w4tFuqskuU31ETnAaWTYRQOYg2WHKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha512-q+4liFwdPC/bNdhUpZx6aXDx/h77yEQtn4I1slHydcbZK34nLaR3cAeYSJshoxIOq3mjEf7xJE8YWIUHMn+oCQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --void: #0a0a0b;
            --deep: #12101a;
            --mystic: #2d2445;
            --gold: #c9a227;
            --gold-dim: rgba(201, 162, 39, 0.4);
            --gold-glow: rgba(201, 162, 39, 0.6);
            --smoke: #9a9a9a;
            --mist: #c4c4c4;
            --pure: #f5f5f5;
            --purple: #8b6fc0;
            --purple-dim: rgba(139, 111, 192, 0.3);

            --color-person: #c9a227;
            --color-organization: #8b6fc0;
            --color-case: #60a5fa;
            --color-location: #4ade80;

            /* Entity Type Colors - Aligned with design spec */
            --entity-person-gov: #E57373;        /* Person: Gov Employee - Reddish */
            --entity-person-ceo: #4DD0E1;        /* Person: CEO/Board - Tealish */
            --entity-person-other: #FFD54F;      /* Person: Other - Yellow */
            --entity-org-banking: #81C784;       /* Org: Banking - Green */
            --entity-org-media: #F48FB1;         /* Org: Media - Pink */
            --entity-org-gov: #5C6BC0;           /* Org: Government - Dark Blue */
            --entity-org-other: #9575CD;         /* Org: Other - Purple */
            --entity-case: #FFB74D;              /* Case - Orange */
            --entity-general: #9E9E9E;           /* Unknown - Gray */

            /* Macro Category Border Colors */
            --macro-people: #FFD54F;
            --macro-gov: #5C6BC0;
            --macro-media: #F48FB1;
            --macro-financial: #81C784;
        }

        html, body {
            font-family: 'Source Sans 3', sans-serif;
            background: var(--void);
            color: var(--mist);
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* LOADING STATE */
        #loadingOverlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--void);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        #loadingOverlay.hidden { opacity: 0; pointer-events: none; }
        .loading-title {
            font-family: 'Cinzel', serif;
            font-size: 1.5rem;
            color: var(--gold);
            letter-spacing: 0.3em;
            margin-bottom: 2rem;
        }
        .loading-spinner {
            width: 50px; height: 50px;
            border: 2px solid var(--purple-dim);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-status {
            margin-top: 1.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--smoke);
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* HEADER */
        header {
            position: fixed;
            top: 0; left: 0; right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.5rem;
            background: rgba(10, 10, 11, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--gold-dim);
            z-index: 1000;  /* Above transition overlay */
        }
        .logo {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            letter-spacing: 0.2em;
            color: var(--gold);
            text-decoration: none;
        }
        .search-container { position: relative; width: 300px; }
        #searchInput {
            width: 100%;
            padding: 0.5rem 1rem 0.5rem 2.5rem;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 20px;
            color: var(--pure);
            font-size: 0.9rem;
        }
        #searchInput:focus { outline: none; border-color: var(--gold); }
        #searchInput::placeholder { color: var(--smoke); }
        .search-icon {
            position: absolute;
            left: 0.75rem; top: 50%;
            transform: translateY(-50%);
            color: var(--smoke);
            width: 18px; height: 18px;
        }
        .header-stats {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--smoke);
        }
        .header-stats span { color: var(--gold); }

        /* GRAPH */
        #graphContainer {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(45, 36, 69, 0.1) 0%, transparent 70%);
        }
        #graphSvg { width: 100%; height: 100%; cursor: grab; }
        #graphSvg:active { cursor: grabbing; }
        .link { fill: none; transition: stroke 0.3s, stroke-width 0.3s, opacity 0.3s; }
        .link.highlighted { stroke: var(--gold) !important; }
        .link.dimmed { opacity: 0.1; }
        .node { cursor: pointer; transition: opacity 0.3s; }
        .node.dimmed { opacity: 0.15; }
        .node-circle { fill: var(--deep); stroke-width: 2; transition: all 0.3s; }
        .node.active .node-circle { stroke-width: 3; filter: drop-shadow(0 0 10px var(--gold-glow)); }
        .node.pinned .node-circle { stroke-dasharray: 4 2; }
        .node.pinned .node-label::after { content: ' üìå'; font-size: 9px; }

        /* FOCAL NODE STYLING (central entity of a network) */
        .node.focal .node-circle {
            stroke: #FFD700 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.6));
        }
        .node.focal .node-label {
            fill: #FFD700;
            font-weight: 600;
            font-size: 13px;
        }
        .node-label {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 11px; fill: var(--mist);
            text-anchor: middle; pointer-events: none;
            transition: fill 0.3s, font-size 0.3s;
        }
        .node.active .node-label { fill: var(--pure); font-size: 13px; font-weight: 500; }
        .node.highlighted .node-label { fill: var(--pure); }
        .node-type-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px; fill: var(--smoke);
            text-anchor: middle; text-transform: uppercase;
        }

        /* DETAIL PANEL */
        #detailPanel {
            position: fixed;
            right: -420px; top: 90px;
            width: 400px;
            max-height: calc(100vh - 110px);
            background: rgba(18, 16, 26, 0.98);
            border: 1px solid var(--gold-dim);
            border-right: none;
            border-radius: 12px 0 0 12px;
            overflow: hidden;
            transition: right 0.3s ease;
            z-index: 200;
        }
        #detailPanel.active { right: 0; }
        .detail-header {
            padding: 1.25rem;
            background: rgba(201, 162, 39, 0.1);
            border-bottom: 1px solid var(--gold-dim);
        }
        .detail-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.5rem;
        }
        .detail-title {
            font-family: 'Cinzel', serif;
            font-size: 1.3rem;
            color: var(--pure);
            line-height: 1.3;
        }
        .detail-status {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--smoke);
            margin-top: 0.5rem;
            line-height: 1.4;
        }
        .detail-close {
            position: absolute;
            top: 1rem; right: 1rem;
            width: 32px; height: 32px;
            background: rgba(139, 111, 192, 0.3);
            border: none; border-radius: 50%;
            color: var(--mist); font-size: 1.2rem;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .detail-close:hover { background: var(--gold); color: var(--void); }
        .detail-content {
            padding: 1.25rem;
            overflow-y: auto;
            max-height: calc(100vh - 240px);
        }
        .detail-content p { margin-bottom: 1rem; line-height: 1.7; font-size: 0.95rem; }
        .detail-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--purple-dim);
        }
        .detail-section h4 {
            font-family: 'Cinzel', serif;
            font-size: 0.85rem;
            color: var(--gold);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }
        .connection-list { list-style: none; }
        .connection-item {
            padding: 0.6rem 0;
            border-bottom: 1px solid rgba(139, 111, 192, 0.1);
            cursor: pointer;
            transition: background 0.2s;
            margin: 0 -1.25rem;
            padding-left: 1.25rem;
            padding-right: 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .connection-item:hover { background: rgba(201, 162, 39, 0.1); }
        .connection-item:last-child { border-bottom: none; }
        .connection-name { color: var(--pure); font-weight: 500; }
        .connection-meta { display: flex; align-items: center; gap: 0.75rem; }
        .connection-type { font-size: 0.65rem; color: var(--smoke); text-transform: uppercase; }
        .connection-evidence {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        .connection-evidence.documented {
            background: rgba(201, 162, 39, 0.25);
            color: var(--gold);
        }
        .connection-evidence.referenced {
            background: rgba(139, 111, 192, 0.25);
            color: var(--purple);
        }
        .connection-evidence.associated {
            background: rgba(154, 154, 154, 0.2);
            color: var(--smoke);
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           CONNECTIONS PANEL - PHASE 4 DROPDOWN UPDATES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        /* Hide old badge labels */
        .connection-evidence {
            display: none !important;
        }

        /* Updated connection item for expandable dropdown */
        .connection-item {
            flex-direction: column;
            align-items: stretch;
            padding: 0;
            cursor: default;
        }

        /* Connection header - clickable to expand */
        .connection-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0.75rem 1.25rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .connection-header:hover {
            background: rgba(201, 162, 39, 0.1);
        }

        /* Expand/collapse icon */
        .connection-expand-icon {
            font-size: 10px;
            color: var(--smoke);
            transition: transform 0.2s;
            width: 12px;
            text-align: center;
        }

        .connection-item.expanded .connection-expand-icon {
            transform: rotate(90deg);
        }

        /* Connection info within header */
        .connection-header-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        /* Dropdown container */
        .connection-dropdown {
            padding: 0 1.25rem 0.75rem 2.5rem;
            border-bottom: 1px solid rgba(139, 111, 192, 0.15);
            animation: dropdownExpand 0.2s ease-out;
        }

        @keyframes dropdownExpand {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Summary text */
        .connection-summary {
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--mist);
            padding: 0.75rem;
            background: rgba(18, 16, 26, 0.6);
            border: 1px solid rgba(139, 111, 192, 0.2);
            border-radius: 6px;
            margin-bottom: 0.75rem;
        }

        /* Sources section */
        .connection-sources {
            padding-top: 0.5rem;
        }

        .connection-sources-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: var(--gold);
            margin-bottom: 0.5rem;
        }

        .connection-sources-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .connection-source-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: rgba(45, 36, 69, 0.4);
            border: 1px solid rgba(139, 111, 192, 0.2);
            border-radius: 4px;
            color: var(--gold);
            text-decoration: none;
            font-size: 0.75rem;
            transition: all 0.2s;
            cursor: pointer;
        }

        .connection-source-link:hover {
            background: rgba(45, 36, 69, 0.7);
            border-color: var(--gold);
        }

        .connection-source-link .source-icon {
            font-size: 0.9rem;
        }

        .connection-source-link .source-title {
            flex: 1;
            color: var(--mist);
        }

        .connection-source-link .source-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--smoke);
        }

        .no-sources {
            font-size: 0.75rem;
            color: var(--smoke);
            font-style: italic;
        }

        /* View Connections Brief button */
        .view-connections-brief-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid rgba(201, 162, 39, 0.4);
            border-radius: 4px;
            color: var(--gold);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-connections-brief-btn:hover {
            background: rgba(201, 162, 39, 0.25);
            border-color: var(--gold);
        }

        /* View connection brief button (in dropdown) */
        .view-connection-brief-btn {
            display: block;
            width: 100%;
            margin-top: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid rgba(201, 162, 39, 0.4);
            border-radius: 4px;
            color: var(--gold);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-connection-brief-btn:hover {
            background: rgba(201, 162, 39, 0.25);
            border-color: var(--gold);
        }

        /* Connections section header update */
        .connections-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .connections-section-header h4 {
            margin: 0;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           PROGRESSIVE WEB CONTROLS
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .progressive-web-controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid rgba(139, 111, 192, 0.2);
            margin-bottom: 0.75rem;
        }

        .show-all-btn {
            background: linear-gradient(135deg, rgba(201, 162, 39, 0.2), rgba(201, 162, 39, 0.1));
            border: 1px solid var(--gold-dim);
            border-radius: 6px;
            padding: 0.5rem 1rem;
            color: var(--gold);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .show-all-btn:hover {
            background: linear-gradient(135deg, rgba(201, 162, 39, 0.3), rgba(201, 162, 39, 0.2));
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.3);
        }

        .revealed-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
        }

        /* Visual indicator for revealed connections */
        .connection-item[data-revealed="true"] .connection-header {
            border-left: 3px solid var(--gold);
            padding-left: calc(1.25rem - 3px);
        }

        .connection-item[data-revealed="true"] .connection-name::after {
            content: " ‚úì";
            color: var(--gold);
            font-size: 0.8em;
        }

        /* Connections Brief Modal (fallback) */
        .connections-brief-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 600;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .connections-brief-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 11, 0.9);
        }

        .connections-brief-content {
            position: relative;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            background: rgba(18, 16, 26, 0.98);
            border: 1px solid var(--gold-dim);
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .connections-brief-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: rgba(201, 162, 39, 0.1);
            border-bottom: 1px solid var(--gold-dim);
        }

        .connections-brief-header h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            color: var(--gold);
            margin: 0;
        }

        .connections-brief-header .close-btn {
            background: none;
            border: none;
            color: var(--mist);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .connections-brief-header .close-btn:hover {
            background: var(--gold);
            color: var(--void);
        }

        .connections-brief-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .source-list { list-style: none; }
        .source-item {
            padding: 0.5rem 0;
            font-size: 0.85rem;
            border-bottom: 1px solid rgba(139, 111, 192, 0.1);
            cursor: pointer;
            transition: background 0.2s;
            margin: 0 -1.25rem;
            padding-left: 1.25rem;
            padding-right: 1.25rem;
        }
        .source-item:hover { background: rgba(201, 162, 39, 0.1); }
        .source-item:last-child { border-bottom: none; }
        .source-ecf {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--gold);
        }
        .source-desc { color: var(--smoke); font-size: 0.8rem; }

        /* ACTION BUTTONS */
        .action-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
            margin-right: 0.5rem;
            padding: 0.6rem 1.2rem;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid var(--gold-dim);
            border-radius: 6px;
            color: var(--gold);
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.85rem;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        .action-btn:hover { background: var(--gold); color: var(--void); }
        .action-btn svg { width: 16px; height: 16px; }

        /* BRIEF VIEWER MODAL */
        #briefViewer {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 11, 0.98);
            z-index: 500;
            display: none;
            flex-direction: column;
        }
        #briefViewer.active { display: flex; }
        .brief-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid var(--gold-dim);
            flex-shrink: 0;
        }
        .brief-header-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }
        .brief-back-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brief-back-btn:hover { background: var(--purple); color: var(--pure); }
        .brief-title-bar {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: var(--gold);
        }
        .brief-nav {
            display: flex;
            gap: 0.5rem;
        }
        .brief-nav-btn {
            padding: 0.5rem 1rem;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brief-nav-btn:hover { border-color: var(--gold); color: var(--gold); }
        .brief-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .brief-container {
            flex: 1;
            overflow-y: auto;
            padding: 2rem 4rem;
        }
        .brief-content {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(18, 16, 26, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 12px;
            padding: 3rem;
        }
        .brief-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: var(--smoke);
        }
        .brief-loading .loading-spinner { width: 40px; height: 40px; margin-bottom: 1rem; }

        /* BRIEF MARKDOWN STYLES */
        .brief-content h1 {
            font-family: 'Cinzel', serif;
            font-size: 2rem;
            color: var(--gold);
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--gold-dim);
        }
        .brief-content h2 {
            font-family: 'Cinzel', serif;
            font-size: 1.4rem;
            color: var(--pure);
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--purple-dim);
        }
        .brief-content h3 {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--gold);
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
        }
        .brief-content h4 {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--mist);
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
        }
        .brief-content p {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.15rem;
            line-height: 1.8;
            color: var(--mist);
            margin-bottom: 1.25rem;
        }
        .brief-content blockquote {
            margin: 1.5rem 0;
            padding: 1.25rem 1.5rem;
            background: rgba(201, 162, 39, 0.08);
            border-left: 3px solid var(--gold);
            border-radius: 0 8px 8px 0;
        }
        .brief-content blockquote p {
            font-style: italic;
            margin-bottom: 0.5rem;
        }
        .brief-content blockquote p:last-child { margin-bottom: 0; }
        .brief-content ul, .brief-content ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }
        .brief-content li {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--mist);
            margin-bottom: 0.5rem;
        }
        .brief-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.95rem;
        }
        .brief-content th, .brief-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--purple-dim);
            text-align: left;
        }
        .brief-content th {
            background: rgba(139, 111, 192, 0.2);
            font-weight: 600;
            color: var(--pure);
        }
        .brief-content td { color: var(--mist); }
        .brief-content tr:nth-child(even) td { background: rgba(45, 36, 69, 0.2); }
        .brief-content strong { color: var(--pure); font-weight: 600; }
        .brief-content em { font-style: italic; }
        .brief-content hr {
            border: none;
            height: 1px;
            background: var(--purple-dim);
            margin: 2rem 0;
        }
        .brief-content code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
            background: rgba(45, 36, 69, 0.6);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--gold);
        }
        .brief-content a {
            color: var(--gold);
            text-decoration: underline;
            text-underline-offset: 2px;
        }
        .brief-content a:hover { color: var(--pure); }

        /* Entity links in brief content */
        .entity-mention {
            color: var(--gold);
            cursor: pointer;
            border-bottom: 1px dotted var(--gold-dim);
            transition: all 0.2s;
        }
        .entity-mention:hover {
            background: rgba(201, 162, 39, 0.2);
            border-bottom-color: var(--gold);
        }

        /* PDF VIEWER MODAL */
        #pdfViewer {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(10, 10, 11, 0.98);
            z-index: 600;
            display: none;
            flex-direction: column;
        }
        #pdfViewer.active { display: flex; }
        .pdf-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 2rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid var(--gold-dim);
            flex-shrink: 0;
            gap: 1rem;
        }
        .pdf-header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex: 1;
            min-width: 0;
        }
        .pdf-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--gold);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pdf-header-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-shrink: 0;
        }
        .pdf-close-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-close-btn:hover { background: var(--purple); color: var(--pure); }
        .pdf-container {
            flex: 1;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        .pdf-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .pdf-canvas-wrapper {
            flex: 1;
            width: 100%;
            overflow: auto;
            -webkit-overflow-scrolling: touch;
            display: flex;
            justify-content: center;
            padding: 1rem;
        }
        .pdf-canvas-wrapper canvas {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            /* Width and height set via JS for crisp retina rendering */
        }
        .pdf-nav-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(18, 16, 26, 0.95);
            border-top: 1px solid var(--purple-dim);
            flex-shrink: 0;
        }
        .pdf-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background: rgba(139, 111, 192, 0.2);
            border: 1px solid var(--purple-dim);
            border-radius: 8px;
            color: var(--mist);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-nav-btn:hover:not(:disabled) {
            background: var(--purple);
            color: var(--pure);
            border-color: var(--purple);
        }
        .pdf-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .pdf-page-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--mist);
            min-width: 80px;
            text-align: center;
        }
        .pdf-zoom-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
            padding-left: 1rem;
            border-left: 1px solid var(--purple-dim);
        }
        .pdf-zoom-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: rgba(45, 36, 69, 0.6);
            border: 1px solid var(--purple-dim);
            border-radius: 6px;
            color: var(--mist);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .pdf-zoom-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
        }
        .pdf-download-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--gold);
            border: none;
            border-radius: 6px;
            color: var(--void);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }
        .pdf-download-link:hover { background: var(--pure); }
        .pdf-placeholder {
            text-align: center;
            color: var(--smoke);
            padding: 2rem;
        }
        .pdf-placeholder h3 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 1rem;
        }
        .pdf-placeholder p { margin-bottom: 1rem; }
        .pdf-download-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--gold);
            border: none;
            border-radius: 6px;
            color: var(--void);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
        }
        .pdf-download-btn:hover { background: var(--pure); }
        .pacer-verify {
            display: inline-block;
            padding: 0.6rem 1rem;
            background: rgba(201, 162, 39, 0.15);
            border: 1px solid var(--gold);
            border-radius: 6px;
            color: var(--mist);
            font-size: 0.9rem;
        }
        .pacer-verify em { color: var(--gold); }
        .pdf-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--smoke);
        }
        .pdf-loading .loading-spinner {
            width: 40px;
            height: 40px;
            margin-bottom: 1rem;
        }
        .pdf-error {
            text-align: center;
            padding: 2rem;
            color: var(--smoke);
        }
        .pdf-error h3 {
            color: #ef4444;
            margin-bottom: 1rem;
        }

        /* Mobile PDF viewer optimizations */
        @media (max-width: 768px) {
            .pdf-header {
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
            }
            .pdf-header-left {
                width: 100%;
                margin-bottom: 0.5rem;
            }
            .pdf-title {
                font-size: 0.8rem;
            }
            .pdf-header-controls {
                width: 100%;
                justify-content: space-between;
            }
            .pdf-close-btn span {
                display: none;
            }
            .pdf-nav-controls {
                padding: 0.75rem;
                gap: 0.75rem;
            }
            .pdf-nav-btn {
                width: 48px;
                height: 48px;
                font-size: 1.3rem;
            }
            .pdf-zoom-controls {
                display: none;
            }
            .pdf-canvas-wrapper {
                padding: 0.5rem;
            }
        }

        /* ECF CLICKABLE LINKS */
        .ecf-link {
            color: var(--gold);
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
            transition: all 0.2s ease;
            padding: 0 0.15em;
            border-radius: 2px;
        }
        .ecf-link:hover {
            color: var(--pure);
            background: rgba(201, 162, 39, 0.2);
            text-decoration-style: solid;
        }
        .ecf-table-row:hover {
            background: rgba(201, 162, 39, 0.1) !important;
        }
        .ecf-table-row td {
            transition: background 0.2s ease;
        }

        /* SOURCE REFERENCE LINKS (case numbers, books, reports) */
        .source-link {
            color: var(--gold);
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
            transition: all 0.2s ease;
            padding: 0 0.15em;
            border-radius: 2px;
        }
        a.source-link {
            cursor: pointer;
        }
        a.source-link:hover {
            color: var(--pure);
            background: rgba(201, 162, 39, 0.2);
            text-decoration-style: solid;
        }
        .source-link-nourl {
            cursor: default;
            text-decoration-style: dotted;
            opacity: 0.85;
        }

        /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
           ENTITIES LAYER STYLES
           ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

        .entities-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--void, #0a0a0b);
            z-index: 10;
        }

        /* Filter Search Bar */
        .entities-search-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(26, 16, 37, 0.95);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 8px;
            padding: 8px 16px;
            backdrop-filter: blur(10px);
        }

        .entities-search-icon {
            color: var(--smoke, #a8a8a8);
            display: flex;
            align-items: center;
        }

        .entities-filter-search {
            width: 300px;
            padding: 8px 12px;
            background: rgba(10, 10, 11, 0.8);
            border: 1px solid rgba(107, 82, 128, 0.4);
            border-radius: 4px;
            color: var(--mist, #d4d4d4);
            font-family: 'Source Sans 3', sans-serif;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .entities-filter-search:focus {
            border-color: var(--gold, #c9a227);
        }

        .entities-filter-search::placeholder {
            color: rgba(168, 168, 168, 0.6);
        }

        .entities-result-count {
            font-size: 12px;
            color: var(--smoke, #a8a8a8);
            font-family: 'JetBrains Mono', monospace;
            white-space: nowrap;
        }

        /* Zoomable Viewport */
        .entities-viewport {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            cursor: grab;
        }

        .entities-viewport:active,
        .entities-viewport.panning {
            cursor: grabbing;
        }

        /* Card Grid Container */
        .entities-card-grid {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            transform-origin: center center;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 220px));
            gap: 20px;
            padding: 160px 60px 60px 60px;
            width: max-content;
            max-width: calc(100vw - 60px);
            min-width: min(700px, calc(100vw - 60px));
        }

        /* Entity Card */
        .entity-card {
            width: 200px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(45, 31, 61, 0.6), rgba(26, 16, 37, 0.8));
            border: 1px solid rgba(107, 82, 128, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .entity-card:hover {
            border-color: var(--gold, #c9a227);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .entity-card-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .entity-card-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--void, #0a0a0b);
            flex-shrink: 0;
        }

        /* Entity type colors */
        .entity-card[data-type="person"] .entity-card-avatar {
            background: var(--color-person, #FFD54F);
        }

        .entity-card[data-type="organization"] .entity-card-avatar {
            background: var(--color-organization, #9575CD);
        }

        .entity-card[data-type="case"] .entity-card-avatar {
            background: var(--color-case, #FFB74D);
        }

        .entity-card-info {
            flex: 1;
            min-width: 0;
        }

        .entity-card-name {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            font-weight: 500;
            color: var(--pure, #f8f8f8);
            line-height: 1.3;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-card-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--smoke, #a8a8a8);
        }

        .entity-card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .entity-card-tag {
            font-size: 9px;
            padding: 2px 6px;
            background: rgba(201, 162, 39, 0.2);
            border: 1px solid rgba(201, 162, 39, 0.3);
            border-radius: 3px;
            color: var(--light-gold, #e8d48b);
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .entity-card-connections {
            font-size: 11px;
            color: var(--smoke, #a8a8a8);
            margin-top: auto;
            padding-top: 8px;
        }

        /* Card visibility for filtering */
        .entity-card.filtered-out {
            display: none;
        }

        /* No results message */
        .entities-no-results {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px 20px;
            color: var(--smoke, #a8a8a8);
            font-size: 16px;
            font-family: 'Source Sans 3', sans-serif;
        }

        /* Category header in entities layer */
        .entities-category-header {
            position: absolute;
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 99;
            font-family: 'Cinzel', serif;
            font-size: 12px;
            letter-spacing: 0.2em;
            color: var(--gold, #c9a227);
            text-transform: uppercase;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .entities-search-container {
                top: 70px;
                padding: 6px 12px;
            }

            .entities-filter-search {
                width: 200px;
                font-size: 13px;
            }

            .entities-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(160px, 180px));
                gap: 15px;
                padding: 140px 20px 40px 20px;
                min-width: auto;
            }

            .entity-card {
                width: 160px;
                padding: 15px;
            }

            .entity-card-avatar {
                width: 32px;
                height: 32px;
                font-size: 12px;
            }

            .entity-card-name {
                font-size: 12px;
            }
        }

        /* LEGEND - Bottom Left, above controls */
        #legend {
            position: fixed;
            bottom: 4.5rem;  /* Increased from 1.5rem to clear controls */
            left: 1.5rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.6rem 1rem;
            background: rgba(18, 16, 26, 0.9);
            border: 1px solid rgba(139, 111, 192, 0.3);
            border-radius: 8px;
            z-index: 50;
            max-width: 300px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.75rem;
            color: var(--smoke);
            cursor: pointer;
            transition: color 0.2s;
        }
        .legend-item:hover { color: var(--pure); }
        .legend-item.active { color: var(--pure); }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

        /* CONTROLS - Bottom Left */
        #controls {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }
        .control-btn {
            width: 36px;
            height: 36px;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid rgba(139, 111, 192, 0.3);
            border-radius: 8px;
            color: var(--mist);
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        .control-btn:hover {
            border-color: var(--gold);
            color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }

        /* TOOLTIP */
        #tooltip {
            position: fixed;
            padding: 0.6rem 0.85rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--gold);
            border-radius: 6px;
            font-size: 0.85rem;
            color: var(--pure);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 280px;
        }
        #tooltip.visible { opacity: 1; }
        #tooltip .tooltip-type {
            font-size: 0.65rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.2rem;
        }
        #tooltip .tooltip-name { font-weight: 500; margin-bottom: 0.3rem; }
        #tooltip .tooltip-connections { font-size: 0.75rem; color: var(--smoke); }

        /* LAYER INDICATOR (Breadcrumb) */
        #layerIndicator {
            position: fixed;
            top: 52px;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1.5rem;
            background: rgba(18, 16, 26, 0.95);
            border-bottom: 1px solid rgba(139, 111, 192, 0.2);
            z-index: 999;  /* Above transition overlay, below header */
            backdrop-filter: blur(10px);
        }
        .layer-crumb {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .layer-crumb:hover {
            color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }
        .layer-crumb.active {
            color: var(--gold);
            font-weight: 600;
            background: rgba(201, 162, 39, 0.15);
        }
        .layer-crumb.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        .layer-separator {
            color: rgba(139, 111, 192, 0.5);
            font-size: 0.8rem;
        }
        .layer-count {
            margin-left: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--smoke);
        }
        .layer-count span { color: var(--gold); }

        /* TRANSITION OVERLAY - positioned to not cover header/indicators */
        #transitionOverlay {
            position: fixed;
            top: 85px;  /* Below header and layer indicator */
            left: 0;
            right: 60px;  /* Leave space for level indicator */
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(45, 36, 69, 0.92), rgba(10, 10, 11, 0.97));
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 200;  /* Below header (1000) and indicators */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #transitionOverlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        .transition-content {
            text-align: center;
        }
        .transition-text {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.2rem;
            margin-top: 1rem;
            letter-spacing: 0.1em;
        }

        /* NETWORK CLUSTER NODES (for zoomed-out view) */
        .network-cluster {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .network-cluster:hover {
            filter: brightness(1.2);
        }
        .network-cluster-bg {
            fill: var(--deep);
            stroke-width: 2;
            rx: 16;
            transition: all 0.3s ease;
        }
        .network-cluster:hover .network-cluster-bg {
            stroke-width: 3;
            filter: drop-shadow(0 0 15px var(--gold-glow));
        }
        .network-cluster-title {
            font-family: 'Cinzel', serif;
            font-size: 13px;
            fill: var(--pure);
            text-anchor: middle;
            font-weight: 500;
        }
        .network-cluster-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            fill: var(--gold);
            text-anchor: middle;
        }
        .network-cluster-status {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 9px;
            fill: var(--smoke);
            text-anchor: middle;
        }
        .network-cluster-center {
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            fill: var(--gold);
            text-anchor: middle;
            letter-spacing: 0.03em;
            text-transform: uppercase;
        }
        .network-cluster.placeholder .network-cluster-bg {
            stroke-dasharray: 6 4;
            opacity: 0.6;
        }
        .network-cluster.placeholder .network-cluster-title {
            fill: var(--smoke);
        }

        /* LAYER NODES (for macro view) */
        .layer-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .layer-node:hover {
            filter: brightness(1.2);
        }
        .layer-node-bg {
            fill: var(--void);
            stroke-width: 3;
            transition: all 0.3s ease;
        }
        .layer-node:hover .layer-node-bg {
            stroke-width: 4;
            filter: drop-shadow(0 0 20px var(--gold-glow));
        }
        .layer-node-title {
            font-family: 'Cinzel', serif;
            font-size: 13px;
            fill: var(--pure);
            text-anchor: middle;
            font-weight: 600;
            letter-spacing: 0.03em;
        }
        .layer-node-verse {
            font-family: 'Cormorant Garamond', serif;
            font-size: 10px;
            fill: var(--gold);
            text-anchor: middle;
            font-style: italic;
        }
        .layer-node-desc {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 11px;
            fill: var(--smoke);
            text-anchor: middle;
        }

        /* DOCUMENT NODES (for zoomed-in document view) */
        .document-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .document-node:hover {
            filter: brightness(1.2);
        }
        .document-node-bg {
            fill: rgba(26, 16, 37, 0.95);
            stroke: rgba(139, 111, 192, 0.6);
            stroke-width: 1;
            stroke-dasharray: 4 2;
            rx: 8;
            transition: all 0.3s ease;
        }
        .document-node:hover .document-node-bg {
            stroke: var(--gold);
            stroke-width: 2;
            filter: drop-shadow(0 0 8px var(--gold-glow));
        }
        .document-node-icon {
            font-size: 1.5rem;
            fill: var(--gold);
            text-anchor: middle;
        }
        .document-node-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            fill: var(--pure);
            text-anchor: middle;
        }
        .document-node-desc {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 8px;
            fill: var(--smoke);
            text-anchor: middle;
        }
        .document-connection {
            stroke: rgba(139, 111, 192, 0.4);
            stroke-dasharray: 4 4;
            stroke-width: 1;
        }

        /* LEVEL INDICATOR BADGE */
        .level-badge {
            position: fixed;
            bottom: 80px;
            left: 1.5rem;
            padding: 0.5rem 1rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--gold-dim);
            border-radius: 8px;
            z-index: 50;
            display: none;
        }
        .level-badge.visible { display: block; }
        .level-badge-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .level-badge-value {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            color: var(--gold);
            margin-top: 0.25rem;
        }

        /* ZOOM HINT */
        .zoom-hint {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem 1rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid var(--purple-dim);
            border-radius: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        .zoom-hint.visible { opacity: 1; }
        .zoom-hint .hint-key {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            background: rgba(139, 111, 192, 0.3);
            border-radius: 4px;
            margin: 0 0.25rem;
            color: var(--gold);
        }

        /* NODE TRANSITIONS */
        .node-entering {
            opacity: 0;
            transform: scale(0.8);
        }
        .node-entered {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .node-exiting {
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        /* LEVEL INDICATOR - Bottom Center (Horizontal) */
        #levelIndicator {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.2rem;
            background: rgba(18, 16, 26, 0.95);
            border: 1px solid rgba(139, 111, 192, 0.3);
            border-radius: 30px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .level-track {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 0.25rem;
        }

        .level-node {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .level-node:hover {
            background: rgba(201, 162, 39, 0.1);
        }

        .level-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(139, 111, 192, 0.4);
            border: 2px solid rgba(139, 111, 192, 0.6);
            transition: all 0.3s;
        }

        .level-node:hover .level-dot {
            border-color: var(--gold);
        }

        .level-node.active .level-dot {
            background: var(--gold);
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.5);
        }

        .level-node.visited .level-dot {
            background: rgba(139, 111, 192, 0.6);
            border-color: rgba(139, 111, 192, 0.8);
        }

        .level-node.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .level-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            color: var(--smoke);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: color 0.2s;
        }

        .level-node:hover .level-label,
        .level-node.active .level-label {
            color: var(--gold);
        }

        .level-connector {
            width: 20px;
            height: 2px;
            background: rgba(139, 111, 192, 0.3);
            transition: background 0.3s;
        }

        .level-connector.active {
            background: var(--gold);
        }

        .zoom-percentage {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            padding-left: 0.75rem;
            border-left: 1px solid rgba(139, 111, 192, 0.3);
            margin-left: 0.5rem;
        }

        @keyframes levelPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        .level-node.transitioning .level-dot {
            animation: levelPulse 0.5s ease;
        }

        /* ZOOM WARNING BANNER */
        #zoomWarning {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 1rem 1.5rem;
            background: rgba(18, 16, 26, 0.98);
            border: 2px solid var(--gold);
            border-radius: 12px;
            z-index: 997;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 30px rgba(201, 162, 39, 0.3);
            min-width: 280px;
        }
        #zoomWarning.active {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }
        #zoomWarning.bounce {
            animation: warningBounce 0.4s ease;
        }
        @keyframes warningBounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            25% { transform: translateX(-50%) translateY(-8px); }
            50% { transform: translateX(-50%) translateY(0); }
            75% { transform: translateX(-50%) translateY(-4px); }
        }
        .warning-content {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .warning-icon {
            font-size: 1.5rem;
            animation: warningPulse 1s ease infinite;
        }
        @keyframes warningPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }
        .warning-text {
            font-family: 'Source Sans 3', sans-serif;
            font-size: 0.9rem;
            color: var(--pure);
        }
        .warning-direction {
            color: var(--gold);
            font-weight: 600;
        }
        .warning-target {
            color: var(--gold);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .warning-hint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--smoke);
            text-align: center;
            margin-bottom: 0.5rem;
        }
        .warning-progress {
            width: 100%;
            height: 4px;
            background: rgba(139, 111, 192, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        .warning-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--gold), #f4d03f);
            border-radius: 2px;
            transition: width 0.15s ease;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            header { padding: 0.5rem 1rem; }
            .logo { font-size: 0.8rem; }
            .search-container { width: 180px; }
            .header-stats { display: none; }
            #detailPanel { width: 100%; right: -100%; border-radius: 0; }
            #legend {
                bottom: 3.5rem;
                left: 1rem;
                max-width: 250px;
                flex-wrap: wrap;
                gap: 0.75rem;
                padding: 0.5rem 0.75rem;
            }
            .legend-item { font-size: 0.65rem; }
            #controls {
                bottom: 1rem;
                left: 1rem;
            }
            .control-btn {
                width: 32px;
                height: 32px;
                font-size: 0.9rem;
            }
            .brief-container { padding: 1rem; }
            .brief-content { padding: 1.5rem; }
            .brief-header { padding: 1rem; }
            /* Layer indicator mobile */
            #layerIndicator {
                top: 48px;
                padding: 0.4rem 0.75rem;
                gap: 0.25rem;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .layer-crumb {
                font-size: 0.6rem;
                padding: 0.2rem 0.4rem;
                white-space: nowrap;
            }
            .layer-separator { font-size: 0.7rem; }
            .zoom-hint { display: none; }
            /* Level indicator mobile */
            #levelIndicator {
                bottom: 1rem;
                padding: 0.5rem 1rem;
                gap: 0.25rem;
            }

            .level-label {
                font-size: 0.55rem;
            }

            .level-connector {
                width: 12px;
            }

            .zoom-percentage {
                display: none;  /* Hide on mobile to save space */
            }
        }
        /* ===============================================
           THEOLOGY LAYER (LEVEL 0) - LANDING EXPERIENCE
           =============================================== */

        #theologyLayer {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100vh;
            background: #000000;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 1.5s ease, visibility 0s linear 1.5s;
        }

        #theologyLayer.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .theology-darkness {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(
                135deg,
                #000000 0%,
                #0a0a0a 50%,
                #1a1612 100%
            );
            z-index: 1;
        }

        .theology-light-source {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .theology-radial-glow {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 150%; height: 150%;
            background: radial-gradient(
                circle at center,
                rgba(212, 175, 55, 0.3) 0%,
                rgba(244, 228, 193, 0.15) 20%,
                rgba(201, 169, 97, 0.08) 40%,
                transparent 70%
            );
            opacity: 0;
            animation: theology-light-emerge 5s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
            animation-delay: 0.5s;
        }

        @keyframes theology-light-emerge {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .theology-content {
            position: relative;
            z-index: 10;
            text-align: center;
            max-width: 900px;
            padding: 2rem;
        }

        .theology-scripture {
            opacity: 0;
            animation: theology-text-reveal 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            animation-delay: 2.5s;
        }

        .theology-verse-text {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.75rem, 5vw, 3.5rem);
            font-weight: 400;
            line-height: 1.4;
            color: #f4e4c1;
            text-shadow:
                0 0 20px rgba(212, 175, 55, 0.6),
                0 0 40px rgba(212, 175, 55, 0.3);
            margin-bottom: 1.5rem;
        }

        .theology-verse-reference {
            display: block;
            font-family: 'Cinzel', serif;
            font-size: clamp(1rem, 2vw, 1.5rem);
            font-weight: 400;
            font-style: normal;
            color: #c9a961;
            opacity: 0.8;
        }

        .theology-dichotomy {
            margin: 3rem 0;
            opacity: 0;
            animation: theology-text-reveal 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            animation-delay: 3.5s;
        }

        .theology-dichotomy-line {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.125rem, 3vw, 1.75rem);
            font-weight: 400;
            color: #d4af37;
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
        }

        .theology-dichotomy-emphasis {
            font-family: 'Cinzel', serif;
            font-size: clamp(1.125rem, 3vw, 1.75rem);
            font-weight: 700;
            color: #ffffff;
            margin-top: 1rem;
            letter-spacing: 0.08em;
        }

        .theology-invitation {
            font-family: 'Cinzel', serif;
            font-size: clamp(1rem, 2vw, 1.25rem);
            font-weight: 400;
            color: #f5f5f0;
            margin-bottom: 3rem;
            opacity: 0;
            animation: theology-text-reveal 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
            animation-delay: 4.5s;
        }

        .theology-enter-button {
            position: relative;
            display: inline-block;
            padding: 1.25rem 3rem;
            font-family: 'Cinzel', serif;
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: 700;
            color: #ffffff;
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            border: 2px solid #d4af37;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            opacity: 0;
            animation: theology-text-reveal 1.5s cubic-bezier(0.4, 0.0, 0.2, 1) forwards,
                       theology-button-pulse 2s ease-in-out infinite;
            animation-delay: 5.5s, 7s;
        }

        .theology-enter-button:hover {
            border-color: #ffffff;
            box-shadow:
                0 0 30px rgba(212, 175, 55, 0.6),
                inset 0 0 20px rgba(212, 175, 55, 0.2);
            transform: scale(1.05);
        }

        .theology-enter-button:active {
            transform: scale(0.98);
        }

        @keyframes theology-text-reveal {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        @keyframes theology-button-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.3); }
            50% { box-shadow: 0 0 25px rgba(212, 175, 55, 0.6); }
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .theology-content {
                padding: 1.5rem;
            }

            .theology-verse-text {
                font-size: clamp(1.25rem, 6vw, 2rem);
            }

            .theology-enter-button {
                padding: 1rem 2rem;
            }
        }

        /* Accessibility */
        @media (prefers-reduced-motion: reduce) {
            .theology-radial-glow,
            .theology-scripture,
            .theology-dichotomy,
            .theology-invitation,
            .theology-enter-button {
                animation: none !important;
                opacity: 1 !important;
            }
        }

    </style>
</head>
<body>
    <!-- THEOLOGY LAYER (Level 0) - Landing Experience -->
    <div id="theologyLayer">
        <div class="theology-darkness"></div>
        <div class="theology-light-source">
            <div class="theology-radial-glow"></div>
        </div>
        <div class="theology-content">
            <div class="theology-dichotomy">
                <p class="theology-dichotomy-line">Light and Darkness.</p>
                <p class="theology-dichotomy-line">Truth and Deception.</p>
                <p class="theology-dichotomy-emphasis">The ancient war continues.</p>
            </div>

            <p class="theology-invitation">The evidence is documented.</p>

            <a href="#" class="theology-enter-button" id="theologyEnter">
                Enter The Continuum
            </a>
        </div>
    </div>

    <div id="loadingOverlay">
        <div class="loading-title">THE CONTINUUM</div>
        <div class="loading-spinner"></div>
        <div class="loading-status" id="loadingStatus">Loading knowledge graph...</div>
    </div>

    <header>
        <a href="/" class="logo">TCR</a>
        <div class="search-container">
            <svg class="search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
            </svg>
            <input type="text" id="searchInput" placeholder="Filter entities...">
        </div>
        <div class="header-stats">
            <span id="entityCount">0</span> entities ¬∑ <span id="connectionCount">0</span> connections
        </div>
    </header>

    <!-- Layer Indicator (Breadcrumb Navigation) -->
    <div id="layerIndicator">
        <span class="layer-crumb" data-level="theology" title="Return to Theology Layer" id="theologyBreadcrumb" style="display: none;">THEOLOGY</span>
        <span class="layer-separator" id="theologySeparator" style="display: none;">‚Ä∫</span>
        <span class="layer-crumb active" data-level="macro" title="View macro categories">MACRO</span>
        <span class="layer-separator">‚Ä∫</span>
        <span class="layer-crumb" data-level="entities" title="View entities">[CATEGORY]</span>
        <span class="layer-separator">‚Ä∫</span>
        <span class="layer-crumb" data-level="web" title="View connections">[ENTITY]</span>
    </div>

    <!-- Transition Overlay -->
    <div id="transitionOverlay">
        <div class="transition-content">
            <div class="loading-spinner"></div>
            <div class="transition-text">Transitioning...</div>
        </div>
    </div>

    <div id="graphContainer">
        <svg id="graphSvg"></svg>
    </div>

    <!-- Entities Layer - Index/Card Grid View -->
    <div id="entitiesLayer" class="entities-layer" style="display: none;">

        <!-- Filter Search Bar (SEPARATE from top global search) -->

        <!-- Zoomable/Pannable Card Container -->
        <div class="entities-viewport" id="entitiesViewport">
            <div class="entities-card-grid" id="entitiesGrid">
                <!-- Cards populated dynamically -->
            </div>
        </div>

    </div>

    <div id="detailPanel">
        <button class="detail-close" id="closeDetail">&times;</button>
        <div class="detail-header">
            <div class="detail-type" id="detailType">Person</div>
            <h2 class="detail-title" id="detailTitle">Entity Name</h2>
            <div class="detail-status" id="detailStatus"></div>
        </div>
        <div class="detail-content" id="detailContent"></div>
    </div>

    <!-- Brief Viewer Modal -->
    <div id="briefViewer">
        <div class="brief-header">
            <div class="brief-header-left">
                <button class="brief-back-btn" id="closeBrief">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Back to Graph
                </button>
                <span class="brief-title-bar" id="briefTitleBar">Analytical Brief</span>
            </div>
            <div class="brief-nav">
                <button class="brief-nav-btn" id="briefPrev" disabled>Previous</button>
                <button class="brief-nav-btn" id="briefNext" disabled>Next</button>
            </div>
        </div>
        <div class="brief-container">
            <div class="brief-content" id="briefContent">
                <div class="brief-loading">
                    <div class="loading-spinner"></div>
                    <p>Loading analytical brief...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- PDF Viewer Modal -->
    <div id="pdfViewer">
        <div class="pdf-header">
            <div class="pdf-header-left">
                <span class="pdf-title" id="pdfTitle">Document Viewer</span>
            </div>
            <div class="pdf-header-controls">
                <a href="#" class="pdf-download-link" id="pdfDownloadLink" target="_blank" style="display: none;">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                    </svg>
                    Download
                </a>
                <button class="pdf-close-btn" id="closePdf">
                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M18 6L6 18M6 6l12 12"/>
                    </svg>
                    <span>Close</span>
                </button>
            </div>
        </div>
        <div class="pdf-container" id="pdfContainer">
            <div class="pdf-placeholder">
                <h3>Document Viewer</h3>
                <p>PDF viewer will appear here when documents are available.</p>
            </div>
        </div>
        <div class="pdf-nav-controls" id="pdfNavControls" style="display: none;">
            <button class="pdf-nav-btn" id="pdfPrevPage" title="Previous Page">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M15 18l-6-6 6-6"/>
                </svg>
            </button>
            <span class="pdf-page-info" id="pdfPageInfo">1 / 1</span>
            <button class="pdf-nav-btn" id="pdfNextPage" title="Next Page">
                <svg viewBox="0 0 24 24" width="20" height="20" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 18l6-6-6-6"/>
                </svg>
            </button>
            <div class="pdf-zoom-controls">
                <button class="pdf-zoom-btn" id="pdfZoomOut" title="Zoom Out">‚àí</button>
                <button class="pdf-zoom-btn" id="pdfZoomIn" title="Zoom In">+</button>
            </div>
        </div>
    </div>

    <div id="legend">
        <div class="legend-item active" data-type="all">
            <div class="legend-dot" style="background: var(--pure)"></div>
            All
        </div>
        <div class="legend-item" data-type="person">
            <div class="legend-dot" style="background: var(--color-person)"></div>
            Person
        </div>
        <div class="legend-item" data-type="organization">
            <div class="legend-dot" style="background: var(--color-organization)"></div>
            Organization
        </div>
        <div class="legend-item" data-type="case">
            <div class="legend-dot" style="background: var(--color-case)"></div>
            Case
        </div>
    </div>

    <div id="controls">
        <button class="control-btn" id="zoomIn" title="Zoom In">+</button>
        <button class="control-btn" id="zoomOut" title="Zoom Out">&minus;</button>
        <button class="control-btn" id="resetView" title="Reset View">&#x27F2;</button>
    </div>

    <!-- Zoom Hint -->
    <div class="zoom-hint" id="zoomHint">
        <span class="hint-key">Ctrl+0</span> Theology
        <span class="hint-key">1</span> Macro
        <span class="hint-key">2</span> Entities
        <span class="hint-key">3</span> Web
    </div>

    <!-- Zoom Warning Banner -->
    <div id="zoomWarning">
        <div class="warning-content">
            <div class="warning-icon">‚ö†</div>
            <div class="warning-text">
                <span class="warning-direction">Zoom out</span> to view <span class="warning-target">Networks</span>
            </div>
        </div>
        <div class="warning-hint">Continue zooming to proceed</div>
        <div class="warning-progress">
            <div class="warning-progress-bar"></div>
        </div>
    </div>

    <!-- Level Indicator (Side Panel) -->
    <div id="levelIndicator">
        <div class="level-track">
            <div class="level-node" data-level="macro">
                <div class="level-dot"></div>
                <div class="level-label">MACRO</div>
            </div>
            <div class="level-connector"></div>
            <div class="level-node active" data-level="entities">
                <div class="level-dot"></div>
                <div class="level-label">ENTITIES</div>
            </div>
            <div class="level-connector"></div>
            <div class="level-node" data-level="web">
                <div class="level-dot"></div>
                <div class="level-label">WEB</div>
            </div>
        </div>
        <div class="zoom-percentage" id="zoomPercentage">100%</div>
    </div>

    <div id="tooltip">
        <div class="tooltip-type"></div>
        <div class="tooltip-name"></div>
        <div class="tooltip-connections"></div>
    </div>

    <script>
        // Configure marked.js
        marked.setOptions({
            breaks: true,
            gfm: true
        });

        // ============================================================
        // DATA LOADING
        // ============================================================
        // Global sources index for PDF availability checking
        let sourcesIndex = null;
        // Global sources registry for auto-linking references
        let sourcesRegistry = null;

        async function loadData() {
            const statusEl = document.getElementById('loadingStatus');
            try {
                statusEl.textContent = 'Fetching entities...';
                const entitiesRes = await fetch('/data/entities.json');
                if (!entitiesRes.ok) throw new Error('Failed to load entities.json');
                const entitiesData = await entitiesRes.json();

                statusEl.textContent = 'Fetching connections...';
                const connectionsRes = await fetch('/data/connections.json');
                if (!connectionsRes.ok) throw new Error('Failed to load connections.json');
                const connectionsData = await connectionsRes.json();

                // Load sources index for PDF availability
                statusEl.textContent = 'Fetching sources index...';
                try {
                    const sourcesRes = await fetch('/sources/index.json');
                    if (sourcesRes.ok) {
                        sourcesIndex = await sourcesRes.json();
                    }
                } catch (e) {
                    console.warn('Sources index not available:', e);
                }

                // Load sources registry for auto-linking references
                statusEl.textContent = 'Fetching sources registry...';
                try {
                    const registryRes = await fetch('/data/sources.json');
                    if (registryRes.ok) {
                        sourcesRegistry = await registryRes.json();
                    }
                } catch (e) {
                    console.warn('Sources registry not available:', e);
                }

                statusEl.textContent = 'Building graph...';
                return {
                    entities: entitiesData.entities,
                    connections: connectionsData.connections
                };
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }

        // ============================================================
        // BRIEF VIEWER
        // ============================================================
        const BriefViewer = {
            currentEntity: null,
            entityList: [],
            currentIndex: -1,

            async open(entity) {
                this.currentEntity = entity;
                this.currentIndex = this.entityList.findIndex(e => e.id === entity.id);
                this.updateNavButtons();

                const viewer = document.getElementById('briefViewer');
                const content = document.getElementById('briefContent');
                const titleBar = document.getElementById('briefTitleBar');

                titleBar.textContent = entity.name;
                content.innerHTML = `
                    <div class="brief-loading">
                        <div class="loading-spinner"></div>
                        <p>Loading analytical brief...</p>
                    </div>
                `;
                viewer.classList.add('active');

                try {
                    const briefPath = `/briefs/entity/${entity.brief_file}`;
                    const response = await fetch(briefPath);

                    if (!response.ok) {
                        throw new Error(`Brief not found: ${briefPath}`);
                    }

                    const markdown = await response.text();
                    const html = this.renderMarkdown(markdown);
                    content.innerHTML = html;

                    // Add click handlers for entity mentions
                    this.linkifyEntityMentions(content);

                } catch (error) {
                    console.error('Error loading brief:', error);
                    content.innerHTML = `
                        <div style="text-align: center; padding: 3rem;">
                            <h2 style="color: var(--gold); margin-bottom: 1rem;">Brief Not Available</h2>
                            <p style="color: var(--smoke); margin-bottom: 1.5rem;">
                                The analytical brief for ${entity.name} could not be loaded.
                            </p>
                            <p style="color: var(--smoke); font-size: 0.9rem;">
                                Expected location: /briefs/entity/${entity.brief_file}
                            </p>
                        </div>
                    `;
                }
            },

            renderMarkdown(markdown) {
                return marked.parse(markdown);
            },

            linkifyEntityMentions(container) {
                // Get all known entity names
                const entityNames = {};
                this.entityList.forEach(e => {
                    entityNames[e.name.toLowerCase()] = e;
                    // Also add common variations
                    const nameParts = e.name.split(' ');
                    if (nameParts.length > 1) {
                        entityNames[nameParts[nameParts.length - 1].toLowerCase()] = e;
                    }
                });

                // Linkify ECF references throughout the brief
                this.linkifyECFReferences(container);

                // Linkify source references (case numbers, books, reports)
                this.linkifySourceReferences(container);
            },

            // Convert ECF references into clickable links
            linkifyECFReferences(container) {
                // Regex patterns to match various ECF reference formats
                const ecfPatterns = [
                    /ECF\s+(?:Doc(?:ument)?\.?\s*)?(\d{3,4}(?:-\d{1,3})?)/gi,
                    /ECF\s+#?\s*(\d{3,4}(?:-\d{1,3})?)/gi,
                    /Document\s+(\d{3,4}-\d{1,3})/gi,
                    /Doc\.\s*(\d{3,4}-\d{1,3})/gi
                ];

                // Combined pattern for all formats
                const combinedPattern = /(?:ECF\s+(?:Doc(?:ument)?\.?\s*)?#?\s*|Document\s+|Doc\.\s*)(\d{3,4}(?:-\d{1,3})?)/gi;

                // Process all text nodes in the container
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    if (combinedPattern.test(node.textContent)) {
                        nodesToProcess.push(node);
                    }
                    combinedPattern.lastIndex = 0; // Reset regex
                }

                // Process each text node
                nodesToProcess.forEach(textNode => {
                    const text = textNode.textContent;
                    const parent = textNode.parentNode;

                    // Skip if already inside a link or ECF link
                    if (parent.tagName === 'A' || parent.classList?.contains('ecf-link')) {
                        return;
                    }

                    // Create a temporary container
                    const span = document.createElement('span');
                    let lastIndex = 0;
                    let match;
                    let hasMatches = false;

                    // Reset and find all matches
                    combinedPattern.lastIndex = 0;
                    const matches = [];
                    while ((match = combinedPattern.exec(text)) !== null) {
                        matches.push({
                            fullMatch: match[0],
                            ecf: match[1],
                            index: match.index
                        });
                    }

                    if (matches.length === 0) return;

                    matches.forEach(m => {
                        hasMatches = true;
                        // Add text before the match
                        if (m.index > lastIndex) {
                            span.appendChild(document.createTextNode(text.slice(lastIndex, m.index)));
                        }

                        // Create clickable ECF link
                        const ecfLink = document.createElement('span');
                        ecfLink.className = 'ecf-link';
                        ecfLink.textContent = m.fullMatch;
                        ecfLink.dataset.ecf = m.ecf;
                        ecfLink.title = `View ECF ${m.ecf}`;
                        ecfLink.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.openECFDocument(m.ecf);
                        });

                        span.appendChild(ecfLink);
                        lastIndex = m.index + m.fullMatch.length;
                    });

                    // Add remaining text
                    if (lastIndex < text.length) {
                        span.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }

                    if (hasMatches) {
                        parent.replaceChild(span, textNode);
                    }
                });

                // Also make table cells with ECF numbers clickable
                this.linkifySourceTables(container);
            },

            // Make source document tables clickable
            linkifySourceTables(container) {
                const tables = container.querySelectorAll('table');
                tables.forEach(table => {
                    const rows = table.querySelectorAll('tbody tr, tr');
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 2) {
                            const firstCell = cells[0];
                            const text = firstCell.textContent.trim();

                            // Check if first cell contains an ECF reference
                            // Handles: 1320-9, 1329-0_1, 1328-44, etc.
                            const ecfMatch = text.match(/^(\d{3,4}(?:-\d{1,3})?(?:_\d+)?)$/);
                            if (ecfMatch) {
                                // Normalize ECF: remove underscore suffix for lookup
                                const ecfRaw = ecfMatch[1];
                                const ecf = ecfRaw.replace(/_\d+$/, '');

                                // Make the entire row clickable
                                row.classList.add('ecf-table-row');
                                row.style.cursor = 'pointer';
                                row.title = `View ECF ${ecf}`;
                                row.addEventListener('click', (e) => {
                                    if (e.target.tagName !== 'A') {
                                        e.preventDefault();
                                        this.openECFDocument(ecf);
                                    }
                                });

                                // Also wrap the ECF number in the cell
                                if (!firstCell.querySelector('.ecf-link')) {
                                    firstCell.innerHTML = `<span class="ecf-link" data-ecf="${ecf}">${text}</span>`;
                                }
                            }
                        }
                    });
                });
            },

            // Open ECF document in PDF viewer
            openECFDocument(ecf) {
                // Get description from current entity's sources if available
                let description = 'Court Document';
                if (this.currentEntity && this.currentEntity.sources) {
                    const sourceDoc = this.currentEntity.sources.find(s => s.ecf === ecf);
                    if (sourceDoc) {
                        description = sourceDoc.description || 'Court Document';
                    }
                }

                // Open the PDF viewer with this ECF
                PDFViewer.open({
                    ecf: ecf,
                    description: description
                });
            },

            // Linkify source references from sources.json (case numbers, books, reports)
            linkifySourceReferences(container) {
                if (!sourcesRegistry) return;

                // Build lookup maps from sources registry
                const aliasMap = sourcesRegistry.aliases || {};
                const cases = sourcesRegistry.cases || {};
                const books = sourcesRegistry.books || {};
                const reports = sourcesRegistry.congressionalReports || {};
                const sources = sourcesRegistry.sources || [];

                // Build a combined lookup for getting URLs
                const getSourceUrl = (id) => {
                    // Check sources array first (for ECF docs)
                    const source = sources.find(s => s.id === id);
                    if (source) {
                        if (source.paperlessId) {
                            return `http://192.168.1.139:8040/api/documents/${source.paperlessId}/preview/`;
                        }
                        return source.url || null;
                    }
                    // Check cases
                    if (cases[id]) {
                        return cases[id].url || null;
                    }
                    // Check books
                    if (books[id]) {
                        if (books[id].paperlessId) {
                            return `http://192.168.1.139:8040/api/documents/${books[id].paperlessId}/preview/`;
                        }
                        return books[id].url || null;
                    }
                    // Check congressional reports
                    if (reports[id]) {
                        if (reports[id].paperlessId) {
                            return `http://192.168.1.139:8040/api/documents/${reports[id].paperlessId}/preview/`;
                        }
                        return reports[id].url || null;
                    }
                    return null;
                };

                // Get display info for a source
                const getSourceInfo = (id) => {
                    if (cases[id]) return { title: cases[id].title, type: 'case' };
                    if (books[id]) return { title: books[id].title, type: 'book' };
                    if (reports[id]) return { title: reports[id].shortName || reports[id].title, type: 'report' };
                    const source = sources.find(s => s.id === id);
                    if (source) return { title: source.title || source.shortName, type: source.type };
                    return null;
                };

                // Sort aliases by length (longest first) to match most specific first
                const sortedAliases = Object.keys(aliasMap).sort((a, b) => b.length - a.length);
                if (sortedAliases.length === 0) return;

                // Build regex pattern from aliases (escape special chars)
                const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const aliasPattern = new RegExp(
                    '\\b(' + sortedAliases.map(escapeRegex).join('|') + ')\\b',
                    'gi'
                );

                // Process all text nodes in the container
                const walker = document.createTreeWalker(
                    container,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );

                const nodesToProcess = [];
                let node;
                while (node = walker.nextNode()) {
                    if (aliasPattern.test(node.textContent)) {
                        nodesToProcess.push(node);
                    }
                    aliasPattern.lastIndex = 0; // Reset regex
                }

                // Process each text node
                nodesToProcess.forEach(textNode => {
                    const text = textNode.textContent;
                    const parent = textNode.parentNode;

                    // Skip if already inside a link or source link
                    if (parent.tagName === 'A' || parent.classList?.contains('source-link') || parent.classList?.contains('ecf-link')) {
                        return;
                    }

                    // Create a temporary container
                    const span = document.createElement('span');
                    let lastIndex = 0;
                    let hasMatches = false;

                    // Reset and find all matches
                    aliasPattern.lastIndex = 0;
                    const matches = [];
                    let match;
                    while ((match = aliasPattern.exec(text)) !== null) {
                        const matchedAlias = match[1];
                        const sourceId = aliasMap[matchedAlias] || aliasMap[matchedAlias.toLowerCase()];
                        // Try case-insensitive lookup
                        const foundAlias = sortedAliases.find(a => a.toLowerCase() === matchedAlias.toLowerCase());
                        const resolvedId = foundAlias ? aliasMap[foundAlias] : sourceId;
                        if (resolvedId) {
                            matches.push({
                                fullMatch: match[0],
                                alias: matchedAlias,
                                sourceId: resolvedId,
                                index: match.index
                            });
                        }
                    }

                    if (matches.length === 0) return;

                    matches.forEach(m => {
                        hasMatches = true;
                        // Add text before the match
                        if (m.index > lastIndex) {
                            span.appendChild(document.createTextNode(text.slice(lastIndex, m.index)));
                        }

                        const url = getSourceUrl(m.sourceId);
                        const info = getSourceInfo(m.sourceId);

                        if (url) {
                            // Create clickable link
                            const link = document.createElement('a');
                            link.className = 'source-link';
                            link.href = url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.textContent = m.fullMatch;
                            link.title = info ? `View: ${info.title}` : `View source`;
                            span.appendChild(link);
                        } else {
                            // No URL available - just style it
                            const styledSpan = document.createElement('span');
                            styledSpan.className = 'source-link source-link-nourl';
                            styledSpan.textContent = m.fullMatch;
                            styledSpan.title = info ? info.title : 'Source document';
                            span.appendChild(styledSpan);
                        }

                        lastIndex = m.index + m.fullMatch.length;
                    });

                    // Add remaining text
                    if (lastIndex < text.length) {
                        span.appendChild(document.createTextNode(text.slice(lastIndex)));
                    }

                    if (hasMatches) {
                        parent.replaceChild(span, textNode);
                    }
                });
            },

            close() {
                document.getElementById('briefViewer').classList.remove('active');
                this.currentEntity = null;
            },

            updateNavButtons() {
                const prevBtn = document.getElementById('briefPrev');
                const nextBtn = document.getElementById('briefNext');

                prevBtn.disabled = this.currentIndex <= 0;
                nextBtn.disabled = this.currentIndex >= this.entityList.length - 1;
            },

            prev() {
                if (this.currentIndex > 0) {
                    const prevEntity = this.entityList[this.currentIndex - 1];
                    if (prevEntity.brief_file) {
                        this.open(prevEntity);
                    }
                }
            },

            next() {
                if (this.currentIndex < this.entityList.length - 1) {
                    const nextEntity = this.entityList[this.currentIndex + 1];
                    if (nextEntity.brief_file) {
                        this.open(nextEntity);
                    }
                }
            }
        };

        // ============================================================
        // PDF VIEWER (with pdf.js for mobile support)
        // ============================================================
        const PDFViewer = {
            // State
            pdfDoc: null,
            currentPage: 1,
            totalPages: 0,
            scale: 1.5,
            currentPdfPath: null,
            rendering: false,

            // Case folder mappings - most briefs cite Giuffre v. Maxwell
            caseInfo: {
                'giuffre-v-maxwell': {
                    citation: 'Giuffre v. Maxwell, No. 15-cv-07433-LAP (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                },
                'epstein-sdny': {
                    citation: 'United States v. Epstein, No. 19-cr-00490 (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                },
                'maxwell-criminal': {
                    citation: 'United States v. Maxwell, No. 20-cr-00330 (S.D.N.Y.)',
                    pacer: 'https://pacer.uscourts.gov'
                }
            },

            init() {
                // Set up pdf.js worker
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }

                // Bind navigation controls
                document.getElementById('pdfPrevPage').addEventListener('click', () => this.prevPage());
                document.getElementById('pdfNextPage').addEventListener('click', () => this.nextPage());
                document.getElementById('pdfZoomIn').addEventListener('click', () => this.zoomIn());
                document.getElementById('pdfZoomOut').addEventListener('click', () => this.zoomOut());
            },

            // Check if PDF is available in sources index
            isPdfAvailable(ecf) {
                if (!sourcesIndex || !sourcesIndex.cases) return { available: false, caseFolder: null };

                // Search all cases for this ECF number
                for (const [folder, caseData] of Object.entries(sourcesIndex.cases)) {
                    const doc = caseData.documents.find(d => d.ecf === ecf);
                    if (doc && doc.available) {
                        return { available: true, caseFolder: folder, filename: doc.filename };
                    }
                }
                return { available: false, caseFolder: 'giuffre-v-maxwell' }; // Default case for PACER link
            },

            // Check if on mobile device
            isMobile() {
                return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            async open(source) {
                const viewer = document.getElementById('pdfViewer');
                const container = document.getElementById('pdfContainer');
                const title = document.getElementById('pdfTitle');
                const navControls = document.getElementById('pdfNavControls');
                const downloadLink = document.getElementById('pdfDownloadLink');

                title.textContent = `ECF ${source.ecf} - ${source.description}`;

                // Reset state
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.scale = this.isMobile() ? 1.0 : 1.5;

                // Check PDF availability from pre-loaded index
                const pdfStatus = this.isPdfAvailable(source.ecf);
                const caseFolder = pdfStatus.caseFolder || 'giuffre-v-maxwell';
                const caseData = this.caseInfo[caseFolder];

                if (pdfStatus.available) {
                    const pdfPath = `/sources/${caseFolder}/${pdfStatus.filename}`;
                    this.currentPdfPath = pdfPath;

                    // Show download link
                    downloadLink.href = pdfPath;
                    downloadLink.style.display = 'flex';

                    // Show loading state
                    container.innerHTML = `
                        <div class="pdf-loading">
                            <div class="loading-spinner"></div>
                            <p>Loading document...</p>
                        </div>
                    `;
                    navControls.style.display = 'none';

                    viewer.classList.add('active');

                    // Try to load with pdf.js
                    await this.loadPDF(pdfPath, container, source, caseData);
                } else {
                    // PDF not available - show PACER verification link
                    downloadLink.style.display = 'none';
                    navControls.style.display = 'none';

                    container.innerHTML = `
                        <div class="pdf-placeholder">
                            <h3>ECF Document ${source.ecf}</h3>
                            <p><strong>${source.description}</strong></p>
                            <p style="margin-top: 1.5rem; font-size: 0.95rem; color: var(--smoke);">
                                This document is not yet available in our archive.
                            </p>
                            <p style="margin-top: 1.5rem;">
                                <span class="pacer-verify">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 0.5rem;">
                                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                                    </svg>
                                    Verify via PACER: <em>${caseData.citation}</em>
                                </span>
                            </p>
                            <p style="margin-top: 1.5rem; font-size: 0.85rem;">
                                <a href="${caseData.pacer}" target="_blank" rel="noopener" style="color: var(--gold);">
                                    Access PACER ‚Üí
                                </a>
                            </p>
                        </div>
                    `;

                    viewer.classList.add('active');
                }
            },

            async loadPDF(pdfPath, container, source, caseData) {
                // Check if pdf.js is available
                if (typeof pdfjsLib === 'undefined') {
                    // Fallback to iframe for desktop, download for mobile
                    this.showFallback(pdfPath, container, source, caseData);
                    return;
                }

                try {
                    // Load the PDF document
                    const loadingTask = pdfjsLib.getDocument(pdfPath);
                    this.pdfDoc = await loadingTask.promise;
                    this.totalPages = this.pdfDoc.numPages;

                    // Set up the canvas container
                    container.innerHTML = `<div class="pdf-canvas-wrapper" id="pdfCanvasWrapper"><canvas id="pdfCanvas"></canvas></div>`;

                    // Show navigation controls
                    document.getElementById('pdfNavControls').style.display = 'flex';
                    this.updatePageInfo();

                    // Render the first page
                    await this.renderPage(this.currentPage);

                    // Add touch/pinch zoom support for mobile
                    this.setupTouchZoom();

                } catch (error) {
                    console.error('Error loading PDF with pdf.js:', error);
                    // Fallback
                    this.showFallback(pdfPath, container, source, caseData);
                }
            },

            showFallback(pdfPath, container, source, caseData) {
                const navControls = document.getElementById('pdfNavControls');
                navControls.style.display = 'none';

                if (this.isMobile()) {
                    // On mobile, show download button prominently
                    container.innerHTML = `
                        <div class="pdf-placeholder">
                            <h3>ECF Document ${source.ecf}</h3>
                            <p><strong>${source.description}</strong></p>
                            <p style="margin-top: 1rem; font-size: 0.9rem;">
                                Source: <em>${caseData.citation}</em>
                            </p>
                            <p style="margin-top: 1.5rem; color: var(--smoke);">
                                For the best viewing experience on mobile, open this document in your device's PDF viewer.
                            </p>
                            <p style="margin-top: 1.5rem;">
                                <a href="${pdfPath}" target="_blank" class="pdf-download-btn">
                                    <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/>
                                    </svg>
                                    Open in PDF Viewer
                                </a>
                            </p>
                        </div>
                    `;
                } else {
                    // On desktop, use iframe
                    container.innerHTML = `<iframe src="${pdfPath}" title="ECF ${source.ecf}"></iframe>`;
                }
            },

            async renderPage(pageNum) {
                if (!this.pdfDoc || this.rendering) return;

                this.rendering = true;
                const canvas = document.getElementById('pdfCanvas');
                const ctx = canvas.getContext('2d');

                try {
                    const page = await this.pdfDoc.getPage(pageNum);

                    // Get device pixel ratio for crisp rendering on retina/high-DPI displays
                    const pixelRatio = window.devicePixelRatio || 1;

                    // Calculate base scale based on container width for mobile
                    let baseScale = this.scale;
                    if (this.isMobile()) {
                        const wrapper = document.getElementById('pdfCanvasWrapper');
                        const wrapperWidth = wrapper.clientWidth - 20; // Account for padding
                        const baseViewport = page.getViewport({ scale: 1 });
                        baseScale = Math.min(wrapperWidth / baseViewport.width, this.scale);
                    }

                    // Create viewport at base scale for CSS dimensions
                    const cssViewport = page.getViewport({ scale: baseScale });

                    // Create viewport at higher resolution for crisp rendering
                    const renderScale = baseScale * pixelRatio;
                    const renderViewport = page.getViewport({ scale: renderScale });

                    // Set canvas dimensions at high resolution
                    canvas.width = renderViewport.width;
                    canvas.height = renderViewport.height;

                    // Set CSS dimensions at logical size (this creates crisp rendering)
                    canvas.style.width = cssViewport.width + 'px';
                    canvas.style.height = cssViewport.height + 'px';

                    const renderContext = {
                        canvasContext: ctx,
                        viewport: renderViewport
                    };

                    await page.render(renderContext).promise;
                    this.updatePageInfo();

                } catch (error) {
                    console.error('Error rendering page:', error);
                }

                this.rendering = false;
            },

            updatePageInfo() {
                const pageInfo = document.getElementById('pdfPageInfo');
                const prevBtn = document.getElementById('pdfPrevPage');
                const nextBtn = document.getElementById('pdfNextPage');

                pageInfo.textContent = `${this.currentPage} / ${this.totalPages}`;
                prevBtn.disabled = this.currentPage <= 1;
                nextBtn.disabled = this.currentPage >= this.totalPages;
            },

            prevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderPage(this.currentPage);
                    // Scroll to top of canvas
                    document.getElementById('pdfCanvasWrapper')?.scrollTo(0, 0);
                }
            },

            nextPage() {
                if (this.currentPage < this.totalPages) {
                    this.currentPage++;
                    this.renderPage(this.currentPage);
                    // Scroll to top of canvas
                    document.getElementById('pdfCanvasWrapper')?.scrollTo(0, 0);
                }
            },

            zoomIn() {
                this.scale = Math.min(this.scale + 0.25, 3);
                this.renderPage(this.currentPage);
            },

            zoomOut() {
                this.scale = Math.max(this.scale - 0.25, 0.5);
                this.renderPage(this.currentPage);
            },

            setupTouchZoom() {
                const wrapper = document.getElementById('pdfCanvasWrapper');
                if (!wrapper) return;

                let initialDistance = 0;
                let initialScale = this.scale;

                wrapper.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        initialDistance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        initialScale = this.scale;
                    }
                }, { passive: true });

                wrapper.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && initialDistance > 0) {
                        const currentDistance = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        const ratio = currentDistance / initialDistance;
                        const newScale = Math.min(Math.max(initialScale * ratio, 0.5), 3);

                        if (Math.abs(newScale - this.scale) > 0.1) {
                            this.scale = newScale;
                            this.renderPage(this.currentPage);
                        }
                    }
                }, { passive: true });

                wrapper.addEventListener('touchend', () => {
                    initialDistance = 0;
                }, { passive: true });
            },

            close() {
                const viewer = document.getElementById('pdfViewer');
                const navControls = document.getElementById('pdfNavControls');
                const downloadLink = document.getElementById('pdfDownloadLink');

                viewer.classList.remove('active');
                navControls.style.display = 'none';
                downloadLink.style.display = 'none';

                // Clean up
                this.pdfDoc = null;
                this.currentPage = 1;
                this.totalPages = 0;
                this.currentPdfPath = null;
            }
        };

        // ============================================================
        // HIERARCHY MANAGER (Hierarchical Zoom)
        // ============================================================
        const HierarchyManager = {
            data: null,
            currentLevel: 'macro',
            previousLevel: null,
            focusedNetwork: 'epstein-network',
            focusedEntity: null,
            selectedCategory: null,  // PEOPLE, GOV, MEDIA, or FINANCIAL
            transitioning: false,
            transitionCooldown: false,
            lastTransitionTime: 0,
            lastZoomScale: 1.0,

            // Warning/bounce-stop state
            pendingTransition: null,        // { from: 'entities', to: 'networks', direction: 'out' }
            warningShownAt: 0,
            bounceStopActive: false,

            // Bidirectional zoom thresholds - ADJUSTED for better readability
            thresholds: {
                // Zooming OUT thresholds (scale decreasing) - triggers when going BELOW
                ENTITIES_TO_NETWORKS: 0.22,    // Below this ‚Üí show network clusters
                NETWORKS_TO_MACRO: 0.35,       // Below this ‚Üí show macro layer view
                DOCUMENTS_TO_ENTITIES: 1.0,    // Below this when in documents ‚Üí return to entities

                // Zooming IN thresholds (scale increasing) - triggers when going ABOVE
                MACRO_TO_NETWORKS: 2.0,        // Above this when in macro ‚Üí show networks (zoom in to see networks)
                NETWORKS_TO_ENTITIES: 1.4,     // Above this when in networks ‚Üí show entities
                ENTITIES_TO_DOCUMENTS: 2.5     // Above this when focused on entity ‚Üí show documents
            },

            // WARNING thresholds - bounce-stop triggers here, actual transition requires continued zoom
            warningThresholds: {
                // Zooming OUT warnings
                ENTITIES_TO_NETWORKS: 0.28,    // Warning at 28%, transition at 22%
                NETWORKS_TO_MACRO: 0.42,       // Warning at 42%, transition at 35%
                DOCUMENTS_TO_ENTITIES: 1.15,   // Warning at 115%, transition at 100%

                // Zooming IN warnings
                MACRO_TO_NETWORKS: 1.7,        // Warning at 170%, transition at 200%
                NETWORKS_TO_ENTITIES: 1.2,     // Warning at 120%, transition at 140%
                ENTITIES_TO_DOCUMENTS: 2.2     // Warning at 220%, transition at 250%
            },

            // Safe zoom values - middle of each level's range to prevent re-triggers
            safeZoom: {
                macro: 1.0,       // Full page view for macro
                networks: 1.0,    // Identity transform - cards already at screen center
                entities: 1.0,
                documents: 3.0
            },

            async init() {
                try {
                    const response = await fetch('/data/hierarchy.json');
                    if (response.ok) {
                        this.data = await response.json();
                        console.log('Hierarchy data loaded:', this.data);
                    } else {
                        console.warn('Hierarchy data not available, using defaults');
                        this.data = this.getDefaultHierarchy();
                    }
                } catch (e) {
                    console.warn('Error loading hierarchy:', e);
                    this.data = this.getDefaultHierarchy();
                }
                this.updateLayerIndicator();
                this.updateSideLevelIndicator();
                this.updateZoomPercentage(1.0);
            },

            getDefaultHierarchy() {
                return {
                    // Macro categories - the four cardinal boxes
                    categories: [
                        { id: 'people', name: 'PEOPLE', position: 'top', color: '#FFD54F' },
                        { id: 'gov', name: 'GOVERNMENT', position: 'left', color: '#5C6BC0' },
                        { id: 'media', name: 'MEDIA', position: 'bottom', color: '#F48FB1' },
                        { id: 'financial', name: 'FINANCIAL', position: 'right', color: '#81C784' }
                    ],
                    // Legacy layer structure for compatibility
                    layers: [{ id: 'intelligence', name: 'Intelligence Networks', children: ['epstein-network'], level: 1 }],
                    networks: [{
                        id: 'epstein-network',
                        name: 'Epstein Network',
                        parent: 'intelligence',
                        entityCount: 15,
                        connectionCount: 78,
                        entities: [],
                        color: '#c9a227'
                    }],
                    zoomConfig: {
                        thresholds: this.thresholds
                    }
                };
            },

            // Check zoom scale and determine if level transition needed (BIDIRECTIONAL with BOUNCE-STOP)
            checkZoomLevel(scale, focusedNode = null) {
                // Don't check during active transition or cooldown
                if (this.transitioning || this.transitionCooldown) {
                    this.lastZoomScale = scale;
                    this.updateZoomPercentage(scale);
                    return false;
                }

                // Prevent rapid re-triggers (500ms minimum between transitions)
                const now = Date.now();
                if (now - this.lastTransitionTime < 500) {
                    this.lastZoomScale = scale;
                    this.updateZoomPercentage(scale);
                    return false;
                }

                const zoomingIn = scale > this.lastZoomScale;
                const zoomingOut = scale < this.lastZoomScale;
                this.lastZoomScale = scale;

                // Update zoom percentage display
                this.updateZoomPercentage(scale);

                // Determine current transition context
                let potentialTransition = null;
                let direction = null;
                let warningThreshold = null;
                let actualThreshold = null;
                let inWarningZone = false;
                let pastThreshold = false;

                // ZOOM OUT CHECKS
                if (this.currentLevel === 'documents') {
                    warningThreshold = this.warningThresholds.DOCUMENTS_TO_ENTITIES;
                    actualThreshold = this.thresholds.DOCUMENTS_TO_ENTITIES;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'documents', to: 'entities' };
                        pastThreshold = scale < actualThreshold;
                    }
                } else if (this.currentLevel === 'entities') {
                    warningThreshold = this.warningThresholds.ENTITIES_TO_NETWORKS;
                    actualThreshold = this.thresholds.ENTITIES_TO_NETWORKS;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'entities', to: 'networks' };
                        pastThreshold = scale < actualThreshold;
                    }
                    // Also check for zoom IN to documents
                    if (!inWarningZone && focusedNode) {
                        warningThreshold = this.warningThresholds.ENTITIES_TO_DOCUMENTS;
                        actualThreshold = this.thresholds.ENTITIES_TO_DOCUMENTS;
                        if (scale > warningThreshold) {
                            inWarningZone = true;
                            direction = 'in';
                            potentialTransition = { from: 'entities', to: 'documents', focusNode: focusedNode };
                            pastThreshold = scale > actualThreshold;
                        }
                    }
                } else if (this.currentLevel === 'networks') {
                    // Check zoom OUT to macro
                    warningThreshold = this.warningThresholds.NETWORKS_TO_MACRO;
                    actualThreshold = this.thresholds.NETWORKS_TO_MACRO;
                    if (scale < warningThreshold) {
                        inWarningZone = true;
                        direction = 'out';
                        potentialTransition = { from: 'networks', to: 'macro' };
                        pastThreshold = scale < actualThreshold;
                    }
                    // Check zoom IN to entities
                    if (!inWarningZone) {
                        warningThreshold = this.warningThresholds.NETWORKS_TO_ENTITIES;
                        actualThreshold = this.thresholds.NETWORKS_TO_ENTITIES;
                        if (scale > warningThreshold) {
                            inWarningZone = true;
                            direction = 'in';
                            potentialTransition = { from: 'networks', to: 'entities' };
                            pastThreshold = scale > actualThreshold;
                        }
                    }
                } else if (this.currentLevel === 'macro') {
                    warningThreshold = this.warningThresholds.MACRO_TO_NETWORKS;
                    actualThreshold = this.thresholds.MACRO_TO_NETWORKS;
                    if (scale > warningThreshold) {
                        inWarningZone = true;
                        direction = 'in';
                        potentialTransition = { from: 'macro', to: 'networks' };
                        pastThreshold = scale > actualThreshold;
                    }
                }

                // Handle warning zone and bounce-stop logic
                if (inWarningZone && potentialTransition) {
                    // Calculate progress through warning zone (0 = just entered, 1 = at threshold)
                    let progress;
                    if (direction === 'out') {
                        // Zooming out: warningThreshold > actualThreshold
                        progress = (warningThreshold - scale) / (warningThreshold - actualThreshold);
                    } else {
                        // Zooming in: warningThreshold < actualThreshold
                        progress = (scale - warningThreshold) / (actualThreshold - warningThreshold);
                    }
                    progress = Math.max(0, Math.min(1, progress));

                    // Show or update warning
                    this.showWarning(direction, potentialTransition.to, progress);
                    this.pendingTransition = potentialTransition;

                    // Check if we should proceed with transition
                    // Require: past threshold AND minimum 300ms in warning zone
                    const timeInWarning = now - this.warningShownAt;
                    if (pastThreshold && timeInWarning > 300) {
                        console.log(`Bounce-stop confirmed: ${potentialTransition.from} ‚Üí ${potentialTransition.to}`);
                        this.hideWarning();
                        if (potentialTransition.focusNode) {
                            this.focusedEntity = potentialTransition.focusNode;
                        }
                        this.transitionToLevel(potentialTransition.to);
                        return true;
                    }
                } else {
                    // Not in warning zone - hide warning if it was showing
                    if (this.bounceStopActive) {
                        this.hideWarning();
                    }
                }

                return false;  // No transition triggered
            },

            // Update zoom percentage display
            updateZoomPercentage(scale) {
                const el = document.getElementById('zoomPercentage');
                if (el) {
                    el.textContent = Math.round(scale * 100) + '%';
                }
            },

            // Show zoom warning with bounce-stop
            showWarning(direction, targetLevel, progress = 0) {
                const warning = document.getElementById('zoomWarning');
                const directionEl = warning.querySelector('.warning-direction');
                const targetEl = warning.querySelector('.warning-target');
                const progressBar = warning.querySelector('.warning-progress-bar');

                directionEl.textContent = direction === 'out' ? 'Zoom out' : 'Zoom in';
                targetEl.textContent = targetLevel.toUpperCase();

                // Update progress bar (0 to 1)
                if (progressBar) {
                    progressBar.style.width = Math.min(100, progress * 100) + '%';
                }

                if (!warning.classList.contains('active')) {
                    warning.classList.add('active');
                    // Trigger bounce animation
                    warning.classList.add('bounce');
                    setTimeout(() => warning.classList.remove('bounce'), 400);
                    this.warningShownAt = Date.now();
                    this.bounceStopActive = true;
                }
            },

            // Hide zoom warning
            hideWarning() {
                const warning = document.getElementById('zoomWarning');
                if (warning) {
                    warning.classList.remove('active');
                }
                this.pendingTransition = null;
                this.bounceStopActive = false;
            },

            // Update warning progress bar
            updateWarningProgress(progress) {
                const progressBar = document.querySelector('#zoomWarning .warning-progress-bar');
                if (progressBar) {
                    progressBar.style.width = Math.min(100, progress * 100) + '%';
                }
            },

            // Transition between hierarchy levels
            async transitionToLevel(targetLevel) {
                if (this.transitioning || targetLevel === this.currentLevel) return;

                // Lock transitions and enable cooldown
                this.transitioning = true;
                this.transitionCooldown = true;
                this.previousLevel = this.currentLevel;

                console.log(`Transitioning: ${this.currentLevel} ‚Üí ${targetLevel}`);

                const overlay = document.getElementById('transitionOverlay');
                const transitionText = overlay.querySelector('.transition-text');

                // Add transitioning class to target level node for pulse animation
                const targetNode = document.querySelector(`#levelIndicator .level-node[data-level="${targetLevel}"]`);
                if (targetNode) {
                    targetNode.classList.add('transitioning');
                    setTimeout(() => targetNode.classList.remove('transitioning'), 500);
                }

                // Set transition message based on direction
                if (this.getLevelDepth(targetLevel) < this.getLevelDepth(this.currentLevel)) {
                    transitionText.textContent = 'Ascending...';
                } else {
                    transitionText.textContent = 'Descending...';
                }

                // Show overlay
                overlay.classList.add('active');

                // Fade out current view
                if (Graph.nodeElements) {
                    Graph.nodeElements.transition().duration(200)
                        .style('opacity', 0)
                        .attr('transform', d => `translate(${d.x}, ${d.y}) scale(0.8)`);
                }
                if (Graph.linkElements) {
                    Graph.linkElements.transition().duration(200)
                        .style('opacity', 0);
                }

                await this.sleep(300);

                // Update current level
                this.currentLevel = targetLevel;
                this.updateLayerIndicator();

                // Rebuild view for new level
                await this.rebuildViewForLevel(targetLevel);

                // Set lastZoomScale to SAFE value for new level to prevent re-trigger
                // The render functions handle the actual D3 zoom transform
                const safeZoom = this.safeZoom[targetLevel] || 1.0;
                this.lastZoomScale = safeZoom;
                this.updateZoomPercentage(safeZoom);

                // Hide overlay
                await this.sleep(100);
                overlay.classList.remove('active');

                // Release transition lock and record time
                this.transitioning = false;
                this.lastTransitionTime = Date.now();

                console.log(`Transition complete. Safe zoom set to ${safeZoom}`);

                // Release cooldown after additional delay to prevent re-triggers
                setTimeout(() => {
                    this.transitionCooldown = false;
                    console.log('Transition cooldown released');
                }, 600);
            },

            getLevelDepth(level) {
                const depths = { macro: 0, entities: 1, web: 2 };
                return depths[level] || 1;
            },

            async rebuildViewForLevel(level) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Clear existing elements
                if (Graph.g) {
                    Graph.g.selectAll('.network-cluster').remove();
                    Graph.g.selectAll('.layer-node').remove();
                    Graph.g.selectAll('.document-node').remove();
                    Graph.g.selectAll('.document-connection').remove();
                }

                switch(level) {
                    case 'macro':
                        await this.renderMacroView();
                        break;
                    case 'entities':
                        await this.renderEntitiesView();
                        break;
                    case 'web':
                        // Web level shows document sources for focused entity
                        await this.renderDocumentsView();
                        break;
                    // Legacy support for old level names
                    case 'networks':
                        await this.renderNetworksView();
                        break;
                    case 'documents':
                        await this.renderDocumentsView();
                        break;
                }
            },

            async renderMacroView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Hide entities layer if visible
                const entitiesLayer = document.getElementById('entitiesLayer');
                if (entitiesLayer) entitiesLayer.style.display = 'none';

                // Show graph container (for macro SVG elements)
                document.getElementById('graphContainer').style.display = 'block';

                // Hide entity nodes and links
                if (Graph.nodeElements) Graph.nodeElements.style('display', 'none');
                if (Graph.linkElements) Graph.linkElements.style('display', 'none');

                // Hide legend in macro view
                const legend = document.getElementById('legend');
                if (legend) legend.style.display = 'none';

                // Clear selected category when going to macro
                this.selectedCategory = null;

                // Get categories from hierarchy data (new structure)
                const categories = this.data?.categories || [
                    { id: 'people', name: 'PEOPLE', position: 'top', color: '#FFD54F' },
                    { id: 'gov', name: 'GOVERNMENT', position: 'left', color: '#5C6BC0' },
                    { id: 'media', name: 'MEDIA', position: 'bottom', color: '#F48FB1' },
                    { id: 'financial', name: 'FINANCIAL', position: 'right', color: '#81C784' }
                ];

                // Create layer nodes group
                const layerGroup = Graph.g.append('g').attr('class', 'layer-nodes');

                const centerX = width / 2;
                const centerY = height / 2;
                const centerRadius = Math.min(width, height) * 0.08;

                // Calculate positions for cardinal directions
                const boxOffset = Math.min(width, height) * 0.32;
                const positions = {
                    top: { x: centerX, y: centerY - boxOffset },
                    left: { x: centerX - boxOffset, y: centerY },
                    bottom: { x: centerX, y: centerY + boxOffset },
                    right: { x: centerX + boxOffset, y: centerY }
                };

                // Store category positions for line drawing
                const categoryPositions = {};

                // Draw gold connecting lines FIRST (behind boxes)
                const linesGroup = layerGroup.append('g').attr('class', 'macro-connection-lines');

                categories.forEach((category) => {
                    const pos = positions[category.position];
                    if (!pos) return;

                    categoryPositions[category.id] = pos;

                    // Draw line from center to category box
                    linesGroup.append('line')
                        .attr('class', 'macro-connection-line')
                        .attr('x1', centerX)
                        .attr('y1', centerY)
                        .attr('x2', pos.x)
                        .attr('y2', pos.y)
                        .attr('stroke', '#c9a227')
                        .attr('stroke-width', 2)
                        .style('opacity', 0)
                        .transition().duration(400)
                        .style('opacity', 0.6);
                });

                // Render category boxes
                categories.forEach((category, i) => {
                    const pos = positions[category.position];
                    if (!pos) return;

                    const node = layerGroup.append('g')
                        .attr('class', 'layer-node macro-category-box')
                        .attr('data-category', category.id)
                        .attr('transform', `translate(${pos.x}, ${pos.y})`)
                        .style('opacity', 0)
                        .style('cursor', 'pointer')
                        .on('click', () => this.handleMacroCategoryClick(category.id));

                    // Box background - 220x100
                    node.append('rect')
                        .attr('class', 'layer-node-bg')
                        .attr('width', 220)
                        .attr('height', 100)
                        .attr('x', -110)
                        .attr('y', -50)
                        .attr('rx', 12)
                        .attr('stroke', category.color || '#c9a227');

                    // Category name only (no subtitle) - centered vertically
                    node.append('text')
                        .attr('class', 'layer-node-title')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('dominant-baseline', 'middle')
                        .attr('text-anchor', 'middle')
                        .attr('fill', 'var(--pure)')
                        .text(category.name);

                    // Fade in with stagger
                    node.transition().duration(300).delay(i * 50)
                        .style('opacity', 1);
                });

                // Add central "Continuum" node
                const continuum = layerGroup.append('g')
                    .attr('class', 'layer-node continuum-node')
                    .attr('transform', `translate(${centerX}, ${centerY})`)
                    .style('opacity', 0);

                continuum.append('circle')
                    .attr('r', centerRadius)
                    .attr('fill', 'var(--void)')
                    .attr('stroke', 'var(--gold)')
                    .attr('stroke-width', 3);

                continuum.append('text')
                    .attr('class', 'layer-node-title')
                    .attr('x', 0)
                    .attr('y', -10)
                    .attr('dominant-baseline', 'middle')
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'var(--gold)')
                    .attr('font-size', '12px')
                    .text('THE');

                continuum.append('text')
                    .attr('class', 'layer-node-title')
                    .attr('x', 0)
                    .attr('y', 10)
                    .attr('dominant-baseline', 'middle')
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'var(--gold)')
                    .attr('font-size', '12px')
                    .text('CONTINUUM');

                continuum.transition().duration(300)
                    .style('opacity', 1);

                // Set zoom to identity (scale 1.0) for macro level
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform, d3.zoomIdentity);
                this.lastZoomScale = 1.0;

                // Update breadcrumb for macro level
                this.updateBreadcrumb('macro', null, null);
            },

            // Handle macro category box click - navigate to entities layer
            handleMacroCategoryClick(categoryId) {
                this.selectedCategory = categoryId;
                this.currentLevel = 'entities';

                // Hide macro view elements
                Graph.g.selectAll('.layer-nodes').remove();

                // Show entities layer with card grid
                EntitiesLayer.show(categoryId);

                this.updateBreadcrumb('entities', categoryId, null);
            },

            // Update breadcrumb display
            updateBreadcrumb(level, category, focalEntity) {
                const indicator = document.getElementById('layerIndicator');
                if (!indicator) return;

                const crumbs = indicator.querySelectorAll('.layer-crumb');
                crumbs.forEach(crumb => {
                    const crumbLevel = crumb.dataset.level;
                    crumb.classList.toggle('active', crumbLevel === level);

                    // Update text based on current state
                    if (crumbLevel === 'entities' && category) {
                        crumb.textContent = category.toUpperCase();
                    } else if (crumbLevel === 'web' && focalEntity) {
                        crumb.textContent = focalEntity;
                    }
                });
            },

            async renderNetworksView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                // Hide entity nodes and links
                if (Graph.nodeElements) Graph.nodeElements.style('display', 'none');
                if (Graph.linkElements) Graph.linkElements.style('display', 'none');

                // Get networks from hierarchy data
                const networks = this.data?.networks || [];

                // Create network cluster nodes
                const networkGroup = Graph.g.append('g').attr('class', 'network-clusters');

                const cols = Math.ceil(Math.sqrt(networks.length));
                const spacing = 220;
                const startX = (width - (cols - 1) * spacing) / 2;
                const startY = height / 2 - 50;

                networks.forEach((network, i) => {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;

                    const isPlaceholder = network.placeholder || network.entityCount === 0;

                    const node = networkGroup.append('g')
                        .attr('class', `network-cluster ${isPlaceholder ? 'placeholder' : ''}`)
                        .attr('transform', `translate(${x}, ${y})`)
                        .style('opacity', 0)
                        .on('click', () => {
                            if (!isPlaceholder) {
                                this.drillIntoNetwork(network.id);
                            }
                        })
                        .on('dblclick', () => {
                            if (!isPlaceholder) {
                                this.drillIntoNetwork(network.id);
                            }
                        });

                    // Uniform box size: 220x100 with padding (matches layer nodes)
                    node.append('rect')
                        .attr('class', 'network-cluster-bg')
                        .attr('width', 220)
                        .attr('height', 100)
                        .attr('x', -110)
                        .attr('y', -50)
                        .attr('stroke', network.color || '#c9a227');

                    node.append('text')
                        .attr('class', 'network-cluster-title')
                        .attr('x', 0)
                        .attr('y', -25)
                        .attr('dominant-baseline', 'middle')
                        .text(network.name);

                    // Split stats into two lines to prevent overflow
                    node.append('text')
                        .attr('class', 'network-cluster-count')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('dominant-baseline', 'middle')
                        .text(`${network.entityCount} entities`);

                    node.append('text')
                        .attr('class', 'network-cluster-count')
                        .attr('x', 0)
                        .attr('y', 18)
                        .attr('dominant-baseline', 'middle')
                        .text(`${network.connectionCount} connections`);

                    node.append('text')
                        .attr('class', 'network-cluster-status')
                        .attr('x', 0)
                        .attr('y', 35)
                        .attr('dominant-baseline', 'middle')
                        .text(network.status || '');

                    // Add central figure indicator for networks with a defined center
                    if (network.id === 'epstein-network') {
                        node.append('text')
                            .attr('class', 'network-cluster-center')
                            .attr('x', 0)
                            .attr('y', -40)
                            .attr('dominant-baseline', 'middle')
                            .text('‚¨§ Jeffrey Epstein');
                    }

                    // Fade in
                    node.transition().duration(300).delay(i * 80)
                        .style('opacity', 1);
                });

                // Set zoom to identity for networks level - cards are already positioned at screen center
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform, d3.zoomIdentity);
                this.lastZoomScale = 1.0;
            },

            async renderEntitiesView() {
                // Remove any network/layer/document nodes
                Graph.g.selectAll('.network-clusters').remove();
                Graph.g.selectAll('.layer-nodes').remove();
                Graph.g.selectAll('.document-nodes').remove();

                // Always show card grid - default to 'people' if no category selected
                const category = this.selectedCategory || 'people';
                this.selectedCategory = category;  // Store it for breadcrumb
                EntitiesLayer.show(category);

                // FIX05: Update breadcrumb when navigating to entities view
                this.updateBreadcrumb('entities', category, null);
            },

            async renderDocumentsView() {
                if (!this.focusedEntity) {
                    await this.renderEntitiesView();
                    return;
                }

                const entity = this.focusedEntity;
                const sources = entity.sources || [];

                if (sources.length === 0) {
                    await this.renderEntitiesView();
                    return;
                }

                // Dim other nodes
                if (Graph.nodeElements) {
                    Graph.nodeElements.classed('dimmed', d => d.id !== entity.id);
                }
                if (Graph.linkElements) {
                    Graph.linkElements.classed('dimmed', true);
                }

                // Create document nodes around the entity
                const docGroup = Graph.g.append('g').attr('class', 'document-nodes');

                const radius = 150;
                sources.slice(0, 8).forEach((source, i) => {
                    const angle = (i / Math.min(sources.length, 8)) * Math.PI * 2 - Math.PI / 2;
                    const x = entity.x + Math.cos(angle) * radius;
                    const y = entity.y + Math.sin(angle) * radius;

                    // Connection line
                    docGroup.append('line')
                        .attr('class', 'document-connection')
                        .attr('x1', entity.x)
                        .attr('y1', entity.y)
                        .attr('x2', x)
                        .attr('y2', y)
                        .style('opacity', 0)
                        .transition().duration(300).delay(i * 50)
                        .style('opacity', 1);

                    // Document node
                    const node = docGroup.append('g')
                        .attr('class', 'document-node')
                        .attr('transform', `translate(${x}, ${y})`)
                        .style('opacity', 0)
                        .on('click', () => {
                            PDFViewer.open(source);
                        });

                    node.append('rect')
                        .attr('class', 'document-node-bg')
                        .attr('width', 100)
                        .attr('height', 60)
                        .attr('x', -50)
                        .attr('y', -30);

                    node.append('text')
                        .attr('class', 'document-node-icon')
                        .attr('y', -5)
                        .text('üìÑ');

                    node.append('text')
                        .attr('class', 'document-node-title')
                        .attr('y', 12)
                        .text(`ECF ${source.ecf}`);

                    const desc = source.description || '';
                    const shortDesc = desc.length > 18 ? desc.substring(0, 16) + '...' : desc;
                    node.append('text')
                        .attr('class', 'document-node-desc')
                        .attr('y', 24)
                        .text(shortDesc);

                    // Fade in
                    node.transition().duration(300).delay(i * 50)
                        .style('opacity', 1);
                });

                // Zoom to center on entity
                const scale = 1.5;
                Graph.svg.transition().duration(500)
                    .call(Graph.zoom.transform,
                        d3.zoomIdentity
                            .translate(window.innerWidth / 2 - entity.x * scale, window.innerHeight / 2 - entity.y * scale)
                            .scale(scale));
            },

            drillIntoLayer(layerId) {
                this.focusedNetwork = null;
                this.transitionToLevel('networks');
            },

            drillIntoNetwork(networkId) {
                this.focusedNetwork = networkId;
                this.focusedEntity = null;
                this.transitionToLevel('entities');
            },

            // Navigate to a specific level from breadcrumb click
            navigateToLevel(level) {
                if (level === this.currentLevel) return;

                // Reset focused items when going up
                if (this.getLevelDepth(level) < this.getLevelDepth(this.currentLevel)) {
                    if (level === 'macro' || level === 'entities') {
                        this.focusedEntity = null;
                    }
                    if (level === 'macro') {
                        this.focusedNetwork = null;
                        this.selectedCategory = null;
                    }
                }

                this.transitionToLevel(level);
            },

            updateLayerIndicator() {
                // Update breadcrumb indicator
                const indicator = document.getElementById('layerIndicator');
                if (indicator) {
                    const crumbs = indicator.querySelectorAll('.layer-crumb');
                    crumbs.forEach(crumb => {
                        const level = crumb.dataset.level;
                        crumb.classList.toggle('active', level === this.currentLevel);

                        // Update text based on current state - new breadcrumb format: MACRO > [CATEGORY] > [ENTITY]
                        if (level === 'macro') {
                            crumb.textContent = 'MACRO';
                        } else if (level === 'entities') {
                            // Show selected category or placeholder
                            crumb.textContent = this.selectedCategory ? this.selectedCategory.toUpperCase() : '[CATEGORY]';
                        } else if (level === 'web') {
                            // Show focused entity name or placeholder
                            crumb.textContent = this.focusedEntity?.name || '[ENTITY]';
                        }
                    });
                }

                // Update side level indicator
                this.updateSideLevelIndicator();
            },

            // Update the side panel level indicator
            updateSideLevelIndicator() {
                const levels = ['macro', 'entities', 'web'];
                const currentIndex = levels.indexOf(this.currentLevel);

                // Update level nodes
                document.querySelectorAll('#levelIndicator .level-node').forEach(node => {
                    const nodeLevel = node.dataset.level;
                    const nodeIndex = levels.indexOf(nodeLevel);

                    node.classList.remove('active', 'visited', 'transitioning');

                    if (nodeLevel === this.currentLevel) {
                        node.classList.add('active');
                    } else if (nodeIndex < currentIndex) {
                        node.classList.add('visited');
                    }

                    // Disable web level if no entity is focused
                    if (nodeLevel === 'web') {
                        node.classList.toggle('disabled', !this.focusedEntity);
                    }
                });

                // Update connectors
                document.querySelectorAll('#levelIndicator .level-connector').forEach((conn, i) => {
                    conn.classList.toggle('active', i < currentIndex);
                });
            },

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // ============================================================
        // ENTITIES LAYER LOGIC
        // ============================================================

        const EntitiesLayer = {
            // State
            currentCategory: null,
            zoom: 1,
            pan: { x: 0, y: 0 },
            isPanning: false,
            lastPanPoint: { x: 0, y: 0 },
            filteredEntities: [],

            // Zoom limits
            ZOOM_MIN: 0.3,
            ZOOM_MAX: 2.0,
            ZOOM_STEP: 0.1,

            // Initialize the entities layer
            init() {
                this.initFilterSearch();
                this.initPanZoom();
            },

            // Show the entities layer for a category
            show(category) {
                this.currentCategory = category;
                HierarchyManager.selectedCategory = category;

                // Hide graph container, show entities layer
                document.getElementById('graphContainer').style.display = 'none';
                document.getElementById('entitiesLayer').style.display = 'block';

                // Render cards
                this.renderCards(category);

                // Reset view
                this.resetView();

                // Clear filter
                const filterInput = document.getElementById('entitiesFilterSearch');
                if (filterInput) filterInput.value = '';

                // Update layer indicator
                HierarchyManager.updateLayerIndicator();
                HierarchyManager.updateSideLevelIndicator();
            },

            // Hide the entities layer
            hide() {
                document.getElementById('entitiesLayer').style.display = 'none';
                document.getElementById('graphContainer').style.display = 'block';
            },

            // Render entity cards for a category
            renderCards(category) {
                const grid = document.getElementById('entitiesGrid');
                if (!grid) return;

                // Get entities from Graph.nodes (loaded from data)
                // FILTER: Only show entities that have approved briefs
                const allEntities = (Graph.nodes || []).filter(e => e.brief);

                // Category filter logic - checks tags, names, and summaries
                const categoryFilters = {
                    'people': (e) => e.type === 'person',
                    'gov': (e) => {
                        const tags = (e.tags || []).map(t => t.toLowerCase());
                        const summaryStr = (e.summary || '').toLowerCase();
                        const govTags = ['government', 'gov', 'agency', 'cia', 'fbi', 'intelligence', 'prosecutor', 'official', 'federal-judiciary', 'doj', 'state-attorney', 'judge', 'politician', 'foreign-official'];
                        return tags.some(tag => govTags.includes(tag)) ||
                               /\b(government|cia|fbi)\b/.test(summaryStr) ||
                               (e.type === 'organization' && e.subtype === 'government');
                    },
                    'media': (e) => {
                        const tagStr = (e.tags || []).join(' ').toLowerCase();
                        const nameStr = (e.name || '').toLowerCase();
                        const summaryStr = (e.summary || '').toLowerCase();
                        return tagStr.includes('media') ||
                               tagStr.includes('journalist') ||
                               tagStr.includes('news') ||
                               tagStr.includes('publisher') ||
                               summaryStr.includes('journalist') ||
                               summaryStr.includes('media') ||
                               (e.type === 'organization' && e.subtype === 'media');
                    },
                    'financial': (e) => {
                        const tagStr = (e.tags || []).join(' ').toLowerCase();
                        const nameStr = (e.name || '').toLowerCase();
                        const summaryStr = (e.summary || '').toLowerCase();
                        // Check tags
                        const tagMatch = tagStr.includes('financial') ||
                                        tagStr.includes('banking') ||
                                        tagStr.includes('bank') ||
                                        tagStr.includes('finance') ||
                                        tagStr.includes('investment') ||
                                        tagStr.includes('hedge') ||
                                        tagStr.includes('fund');
                        // Check name for known financial entities
                        const nameMatch = nameStr.includes('bank') ||
                                         nameStr.includes('jp morgan') ||
                                         nameStr.includes('deutsche') ||
                                         nameStr.includes('goldman') ||
                                         nameStr.includes('morgan stanley');
                        // Check summary for financial keywords
                        const summaryMatch = summaryStr.includes('hedge fund') ||
                                            summaryStr.includes('investment') ||
                                            summaryStr.includes('banker') ||
                                            summaryStr.includes('financier') ||
                                            summaryStr.includes('wall street');
                        // Check subtype
                        const subtypeMatch = e.type === 'organization' && e.subtype === 'banking';
                        return tagMatch || nameMatch || summaryMatch || subtypeMatch;
                    }
                };

                // If 'people' category, show all persons; for others filter by tags
                // For now, default to showing all entities if category doesn't match
                let filterFn = categoryFilters[category];
                if (!filterFn) {
                    filterFn = () => true;
                }

                // Filter and sort entities
                this.filteredEntities = allEntities.filter(filterFn);

                // Sort by connection count (most connected first)
                this.filteredEntities.sort((a, b) => {
                    const aConns = a.connectionCount || (a.connections || []).length || 0;
                    const bConns = b.connectionCount || (b.connections || []).length || 0;
                    return bConns - aConns;
                });

                // If no filtered entities but we have entities, show all for that category as fallback
                if (this.filteredEntities.length === 0 && allEntities.length > 0 && category === 'people') {
                    this.filteredEntities = allEntities.filter(e => e.type === 'person');
                }

                // Generate HTML
                if (this.filteredEntities.length === 0) {
                    grid.innerHTML = `
                        <div class="entities-no-results">
                            No entities found in ${category.toUpperCase()} category
                        </div>
                    `;
                } else {
                    grid.innerHTML = this.filteredEntities.map(entity => this.createCardHTML(entity)).join('');
                }

                // Update count
                this.updateResultCount(this.filteredEntities.length);

                // Attach click handlers
                this.attachCardHandlers();
            },

            // Create HTML for a single entity card
            createCardHTML(entity) {
                const name = entity.name || entity.nm || entity.id || 'Unknown';
                const initials = this.getInitials(name);
                const type = entity.type || 'entity';
                const tags = (entity.tags || []).slice(0, 3);
                const connCount = entity.connectionCount || (entity.connections || []).length || 0;

                return `
                    <div class="entity-card"
                         data-entity-id="${entity.id}"
                         data-type="${type}"
                         data-name="${name.toLowerCase()}"
                         data-tags="${(entity.tags || []).join(' ').toLowerCase()}"
                         data-connections="${connCount}">
                        <div class="entity-card-header">
                            <div class="entity-card-avatar">${initials}</div>
                            <div class="entity-card-info">
                                <div class="entity-card-name" title="${name}">${name}</div>
                                <div class="entity-card-type">${type}</div>
                            </div>
                        </div>
                        ${tags.length > 0 ? `
                            <div class="entity-card-tags">
                                ${tags.map(tag => `<span class="entity-card-tag">${tag}</span>`).join('')}
                            </div>
                        ` : ''}
                        <div class="entity-card-connections">${connCount} connection${connCount !== 1 ? 's' : ''}</div>
                    </div>
                `;
            },

            // Get initials from name
            getInitials(name) {
                if (!name) return '?';
                return name.split(' ')
                    .filter(word => word.length > 0)
                    .map(word => word[0])
                    .join('')
                    .substring(0, 2)
                    .toUpperCase();
            },

            // Update result count display
            updateResultCount(count) {
                const countEl = document.getElementById('entitiesResultCount');
                if (countEl) {
                    countEl.textContent = `${count} ${count === 1 ? 'entity' : 'entities'}`;
                }
            },

            // Attach click handlers to cards
            attachCardHandlers() {
                document.querySelectorAll('.entity-card').forEach(card => {
                    card.addEventListener('click', (e) => {
                        const entityId = card.dataset.entityId;
                        if (!entityId) return;
                        this.navigateToWebWithEntity(entityId);
                    });
                });
            },

            // Navigate to Web layer with focal entity - Progressive Web Mode
            navigateToWebWithEntity(entityId) {
                // Find entity data
                const entity = Graph.nodes.find(n => n.id === entityId);
                if (!entity) {
                    console.warn('Entity not found:', entityId);
                    return;
                }

                // Store focal entity
                HierarchyManager.focusedEntity = entity;

                // PROGRESSIVE WEB: Reset revealed nodes and set focal
                Graph.revealedNodes.clear();
                Graph.revealedNodes.add(entityId);
                Graph.focalNodeId = entityId;

                // Hide entities layer, show graph
                this.hide();

                // IMPORTANT: Ensure graph container is visible
                document.getElementById('graphContainer').style.display = 'block';

                // Transition to web layer
                HierarchyManager.currentLevel = 'web';
                HierarchyManager.updateLayerIndicator();
                HierarchyManager.updateSideLevelIndicator();

                // PROGRESSIVE WEB: Apply progressive visibility (only focal node visible)
                Graph.applyProgressiveVisibility();

                // Show legend
                const legend = document.getElementById('legend');
                if (legend) legend.style.display = 'flex';

                // Focus on the entity (opens detail panel)
                Graph.selectNode(entity);

                // Center on focal node
                if (entity.x === undefined || entity.y === undefined || isNaN(entity.x) || isNaN(entity.y)) {
                    // Run simulation briefly to get positions
                    Graph.simulation.alpha(0.3).restart();
                    setTimeout(() => {
                        Graph.centerOnNode(entity);
                    }, 500);
                } else {
                    setTimeout(() => {
                        Graph.centerOnNode(entity);
                    }, 100);
                }
            },

            // Initialize filter search
            initFilterSearch() {
                const searchInput = document.getElementById('entitiesFilterSearch');
                if (!searchInput) return;

                let searchTimeout;
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        this.filterCards(e.target.value);
                    }, 150);
                });

                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        searchInput.value = '';
                        this.filterCards('');
                        searchInput.blur();
                    }
                });
            },

            // Filter visible cards
            filterCards(query) {
                const cards = document.querySelectorAll('.entity-card');
                const searchTerms = query.toLowerCase().trim().split(/\s+/).filter(Boolean);

                let visibleCount = 0;

                cards.forEach(card => {
                    if (searchTerms.length === 0) {
                        card.classList.remove('filtered-out');
                        visibleCount++;
                        return;
                    }

                    const name = card.dataset.name || '';
                    const tags = card.dataset.tags || '';
                    const searchableText = `${name} ${tags}`;

                    const matches = searchTerms.every(term => searchableText.includes(term));

                    if (matches) {
                        card.classList.remove('filtered-out');
                        visibleCount++;
                    } else {
                        card.classList.add('filtered-out');
                    }
                });

                this.updateResultCount(visibleCount);

                // Show no results message if needed
                const grid = document.getElementById('entitiesGrid');
                let noResults = grid.querySelector('.entities-no-results');

                if (visibleCount === 0 && searchTerms.length > 0) {
                    if (!noResults) {
                        noResults = document.createElement('div');
                        noResults.className = 'entities-no-results';
                        grid.appendChild(noResults);
                    }
                    noResults.textContent = `No entities match "${query}"`;
                    noResults.style.display = 'block';
                } else if (noResults) {
                    noResults.style.display = 'none';
                }
            },

            // Initialize pan and zoom
            initPanZoom() {
                const viewport = document.getElementById('entitiesViewport');
                const grid = document.getElementById('entitiesGrid');
                if (!viewport || !grid) return;

                // Mouse wheel zoom
                viewport.addEventListener('wheel', (e) => {
                    if (e.target.closest('.entities-search-container')) return;
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -this.ZOOM_STEP : this.ZOOM_STEP;
                    this.setZoom(this.zoom + delta, e.clientX, e.clientY);
                }, { passive: false });

                // Pan with mouse drag
                viewport.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.entity-card') || e.target.closest('.entities-search-container')) return;
                    this.isPanning = true;
                    this.lastPanPoint = { x: e.clientX, y: e.clientY };
                    viewport.classList.add('panning');
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isPanning) return;

                    const dx = e.clientX - this.lastPanPoint.x;
                    const dy = e.clientY - this.lastPanPoint.y;

                    this.pan.x += dx;
                    this.pan.y += dy;
                    this.lastPanPoint = { x: e.clientX, y: e.clientY };

                    this.updateTransform();
                });

                document.addEventListener('mouseup', () => {
                    this.isPanning = false;
                    viewport.classList.remove('panning');
                });

                // Touch support
                let lastTouchDistance = 0;

                viewport.addEventListener('touchstart', (e) => {
                    if (e.target.closest('.entity-card') || e.target.closest('.entities-search-container')) return;

                    if (e.touches.length === 1) {
                        this.isPanning = true;
                        this.lastPanPoint = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    } else if (e.touches.length === 2) {
                        lastTouchDistance = this.getTouchDistance(e.touches);
                    }
                }, { passive: true });

                viewport.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 1 && this.isPanning) {
                        const dx = e.touches[0].clientX - this.lastPanPoint.x;
                        const dy = e.touches[0].clientY - this.lastPanPoint.y;

                        this.pan.x += dx;
                        this.pan.y += dy;
                        this.lastPanPoint = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };

                        this.updateTransform();
                    } else if (e.touches.length === 2) {
                        const distance = this.getTouchDistance(e.touches);
                        const delta = (distance - lastTouchDistance) * 0.005;
                        lastTouchDistance = distance;

                        const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                        this.setZoom(this.zoom + delta, centerX, centerY);
                    }
                }, { passive: true });

                viewport.addEventListener('touchend', () => {
                    this.isPanning = false;
                    lastTouchDistance = 0;
                });
            },

            // Get distance between two touch points
            getTouchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            },

            // Set zoom level
            setZoom(newZoom, pivotX, pivotY) {
                const oldZoom = this.zoom;
                this.zoom = Math.max(this.ZOOM_MIN, Math.min(this.ZOOM_MAX, newZoom));

                // Adjust pan to zoom toward cursor
                if (pivotX !== undefined && pivotY !== undefined) {
                    const viewport = document.getElementById('entitiesViewport');
                    if (viewport) {
                        const rect = viewport.getBoundingClientRect();
                        const viewportCenterX = rect.width / 2;
                        const viewportCenterY = rect.height / 2;

                        const cursorOffsetX = pivotX - rect.left - viewportCenterX - this.pan.x;
                        const cursorOffsetY = pivotY - rect.top - viewportCenterY - this.pan.y;

                        const zoomRatio = this.zoom / oldZoom;

                        this.pan.x -= cursorOffsetX * (zoomRatio - 1);
                        this.pan.y -= cursorOffsetY * (zoomRatio - 1);
                    }
                }

                this.updateTransform();
            },

            // Update grid transform
            updateTransform() {
                const grid = document.getElementById('entitiesGrid');
                if (!grid) return;

                grid.style.transform = `translate(calc(-50% + ${this.pan.x}px), calc(-50% + ${this.pan.y}px)) scale(${this.zoom})`;
            },

            // Reset view to default
            resetView() {
                this.zoom = 1;
                this.pan = { x: 0, y: 0 };
                this.updateTransform();
            }
        };

        // ============================================================
        // GRAPH VISUALIZATION
        // ============================================================
        const Graph = {
            svg: null,
            g: null,
            simulation: null,
            nodes: [],
            links: [],
            zoom: null,
            activeNode: null,
            filterType: 'all',

            // Progressive Web: Track which nodes are revealed through exploration
            revealedNodes: new Set(),
            focalNodeId: null,
            nodeElements: null,
            linkElements: null,

            colors: {
                person: '#c9a227',
                organization: '#8b6fc0',
                case: '#60a5fa',
                location: '#4ade80'
            },

            // Entity type colors - Aligned with design spec
            entityColors: {
                // Person types
                'person-gov': '#E57373',      // Government Employee - Reddish
                'person-ceo': '#4DD0E1',      // CEO/Board Member - Tealish
                'person-other': '#FFD54F',    // Other Person - Yellow

                // Organization types
                'org-banking': '#81C784',     // Banking/Financial - Green
                'org-media': '#F48FB1',       // Media - Pink
                'org-gov': '#5C6BC0',         // Government Agency - Dark Blue
                'org-other': '#9575CD',       // Other Organization - Purple

                // Case type
                'case': '#FFB74D',            // Legal Case - Orange

                // Fallback
                'general': '#9E9E9E'          // Unknown - Gray
            },

            // Classify an entity and return its colors (supports type/tag detection)
            getEntityColors(entity) {
                const tags = entity.tags || [];
                const type = (entity.type || '').toLowerCase();
                const tagStr = tags.join(' ').toLowerCase();
                const summaryStr = (entity.summary || '').toLowerCase();

                // Case entities
                if (type === 'case') {
                    return [this.entityColors['case']];
                }

                // Organization entities
                if (type === 'organization') {
                    if (tagStr.includes('banking') || tagStr.includes('bank') ||
                        tagStr.includes('finance') || tagStr.includes('financial')) {
                        return [this.entityColors['org-banking']];
                    }
                    if (tagStr.includes('media') || tagStr.includes('news') ||
                        tagStr.includes('journalist')) {
                        return [this.entityColors['org-media']];
                    }
                    if (tagStr.includes('government') || tagStr.includes('agency') ||
                        tagStr.includes('cia') || tagStr.includes('fbi') ||
                        tagStr.includes('intelligence')) {
                        return [this.entityColors['org-gov']];
                    }
                    return [this.entityColors['org-other']];
                }

                // Person entities
                if (type === 'person') {
                    // Check for government/official tags or summary keywords
                    if (tagStr.includes('government') || tagStr.includes('official') ||
                        tagStr.includes('prosecutor') || tagStr.includes('agent') ||
                        tagStr.includes('cia') || tagStr.includes('fbi') ||
                        summaryStr.includes('prosecutor') || summaryStr.includes(' fbi ') ||
                        summaryStr.includes(' cia ') || summaryStr.includes('attorney general')) {
                        return [this.entityColors['person-gov']];
                    }

                    // Check for CEO/executive tags or summary keywords
                    if (tagStr.includes('ceo') || tagStr.includes('executive') ||
                        tagStr.includes('chairman') || tagStr.includes('director') ||
                        tagStr.includes('board') || tagStr.includes('founder') ||
                        tagStr.includes('ceo-board') ||
                        summaryStr.includes('ceo') || summaryStr.includes('chairman') ||
                        summaryStr.includes('hedge fund') || summaryStr.includes('financier') ||
                        summaryStr.includes('banker') || summaryStr.includes('investor')) {
                        return [this.entityColors['person-ceo']];
                    }

                    // Default person color
                    return [this.entityColors['person-other']];
                }

                // Unknown type
                return [this.entityColors['general']];
            },

            async init() {
                try {
                    const data = await loadData();
                    this.buildGraph(data);
                    document.getElementById('loadingOverlay').classList.add('hidden');
                } catch (error) {
                    this.showError(error.message);
                }
            },

            // Calculate node depths from focal entity using BFS
            calculateNodeDepths(nodes, links, focalId) {
                const depths = {};
                const adjacency = {};

                // Build adjacency list
                nodes.forEach(n => { adjacency[n.id] = []; });
                links.forEach(l => {
                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                    if (adjacency[sourceId]) adjacency[sourceId].push(targetId);
                    if (adjacency[targetId]) adjacency[targetId].push(sourceId);
                });

                // BFS from focal node
                const queue = [focalId];
                depths[focalId] = 0;
                let maxDepth = 0;

                while (queue.length > 0) {
                    const current = queue.shift();
                    const neighbors = adjacency[current] || [];
                    for (const neighbor of neighbors) {
                        if (depths[neighbor] === undefined) {
                            depths[neighbor] = depths[current] + 1;
                            maxDepth = Math.max(maxDepth, depths[neighbor]);
                            queue.push(neighbor);
                        }
                    }
                }

                // Assign max+1 depth to disconnected nodes
                nodes.forEach(n => {
                    if (depths[n.id] === undefined) {
                        depths[n.id] = maxDepth + 1;
                    }
                });

                return { depths, maxDepth: maxDepth + 1 };
            },

            // Create or get gradient ID for an entity's colors
            getGradientId(entity) {
                const colors = this.getEntityColors(entity);
                if (colors.length === 1) {
                    return null; // Single color, no gradient needed
                }
                // Create a unique ID based on colors
                return 'gradient-' + colors.map(c => c.replace('#', '')).join('-');
            },

            // Create SVG gradient definitions for all entities
            createGradients(defs, nodes) {
                const createdGradients = new Set();

                nodes.forEach(node => {
                    const colors = this.getEntityColors(node);
                    if (colors.length > 1) {
                        const gradientId = this.getGradientId(node);
                        if (!createdGradients.has(gradientId)) {
                            createdGradients.add(gradientId);

                            const gradient = defs.append('linearGradient')
                                .attr('id', gradientId)
                                .attr('x1', '0%')
                                .attr('y1', '0%')
                                .attr('x2', '100%')
                                .attr('y2', '100%');

                            const step = 100 / (colors.length - 1);
                            colors.forEach((color, i) => {
                                gradient.append('stop')
                                    .attr('offset', `${i * step}%`)
                                    .attr('stop-color', color);
                            });
                        }
                    }
                });
            },

            // Get stroke style for a node (gradient URL or single color)
            getNodeStroke(node) {
                const colors = this.getEntityColors(node);
                if (colors.length === 1) {
                    return colors[0];
                }
                return `url(#${this.getGradientId(node)})`;
            },

            buildGraph(data) {
                this.svg = d3.select('#graphSvg');
                const width = window.innerWidth;
                const height = window.innerHeight;

                this.g = this.svg.append('g');

                // Create defs for gradients
                this.defs = this.svg.append('defs');

                this.zoom = d3.zoom()
                    .scaleExtent([0.05, 4])  // Allow zooming out further for macro view
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                        // Check if zoom level triggers hierarchy transition (BIDIRECTIONAL for all levels)
                        // Only check if not in transition and not in cooldown
                        if (!HierarchyManager.transitioning && !HierarchyManager.transitionCooldown) {
                            const transitioned = HierarchyManager.checkZoomLevel(event.transform.k, this.activeNode);
                            // If transition was triggered, stop processing further zoom events
                            if (transitioned) {
                                return;
                            }
                        } else {
                            // Still update the zoom percentage display during cooldown
                            HierarchyManager.updateZoomPercentage(event.transform.k);
                        }
                    });
                this.svg.call(this.zoom);

                const centerX = width / 2;
                const centerY = height / 2;

                // Find focal entity ID
                const focalEntity = data.entities.find(e => this.isFocalEntity(e));
                const focalId = focalEntity ? focalEntity.id : null;

                this.nodes = data.entities.map(e => {
                    const connectionCount = data.connections.filter(
                        c => c.source === e.id || c.target === e.id
                    ).length;
                    const isFocal = this.isFocalEntity(e);
                    const entityColors = this.getEntityColors(e);
                    const node = {
                        ...e,
                        radius: this.getRadius(e.type, connectionCount, isFocal),
                        connectionCount,
                        isFocal: isFocal,
                        entityColors: entityColors
                    };
                    // Pin focal entity to center-top area for top-down layout
                    if (isFocal) {
                        node.fx = centerX;
                        node.fy = height * 0.15; // Position focal at top 15%
                        node.x = centerX;
                        node.y = height * 0.15;
                    }
                    return node;
                });

                // Calculate node depths for top-down layout
                const { depths, maxDepth } = this.calculateNodeDepths(this.nodes, data.connections, focalId);
                this.nodeDepths = depths;
                this.maxNodeDepth = maxDepth;

                // Assign depth to each node
                this.nodes.forEach(node => {
                    node.depth = depths[node.id] || maxDepth;
                });

                // Create gradients for multi-tag entities
                this.createGradients(this.defs, this.nodes);

                // Store entity list for brief navigation
                BriefViewer.entityList = this.nodes.filter(n => n.brief_file).sort((a, b) =>
                    a.name.localeCompare(b.name)
                );

                this.links = data.connections.map(c => ({
                    source: c.source,
                    target: c.target,
                    strength: c.strength,
                    type: c.type,
                    bidirectional: c.bidirectional,
                    evidence: c.evidence
                }));

                // Pre-calculate stable positions before rendering
                // Run simulation silently for 300 iterations to find equilibrium
                // Calculate Y positions based on depth for top-down gravity flow
                const depthSpacing = (height * 0.7) / (this.maxNodeDepth || 1);
                const topOffset = height * 0.15; // Start below focal

                this.simulation = d3.forceSimulation(this.nodes)
                    .force('link', d3.forceLink(this.links)
                        .id(d => d.id)
                        .distance(d => 120 - (d.strength / 4))
                        .strength(d => 0.4 + (d.strength / 150)))
                    .force('charge', d3.forceManyBody()
                        .strength(d => -150 - (d.connectionCount * 15))
                        .distanceMax(400))
                    .force('centerX', d3.forceX(width / 2).strength(0.05))
                    // Top-down gravity: pull nodes to Y positions based on depth
                    .force('depthY', d3.forceY(d => {
                        if (d.isFocal) return topOffset;
                        return topOffset + (d.depth * depthSpacing);
                    }).strength(0.3))
                    .force('collision', d3.forceCollide()
                        .radius(d => d.radius + 20)
                        .strength(0.8)
                        .iterations(2))
                    .stop(); // Don't start automatically

                // Run 300 iterations silently to find stable positions
                for (let i = 0; i < 300; i++) {
                    this.simulation.tick();
                }

                // Now start with very low alpha for minimal movement
                // High decay = settles quickly, low alpha = minimal bouncing
                this.simulation
                    .alpha(0.01)
                    .alphaDecay(0.08)
                    .alphaMin(0.001)
                    .velocityDecay(0.4)
                    .on('tick', () => this.tick())
                    .restart();

                this.linkElements = this.g.append('g')
                    .attr('class', 'links')
                    .selectAll('line')
                    .data(this.links)
                    .enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', d => this.getLinkColor(d))
                    .attr('stroke-width', d => this.getLinkWidth(d))
                    .attr('stroke-opacity', d => d.bidirectional || d.type === 'documented' ? 0.7 : 0.4)
                    .style('display', 'none');  // Hidden initially - start at macro

                this.nodeElements = this.g.append('g')
                    .attr('class', 'nodes')
                    .selectAll('g')
                    .data(this.nodes)
                    .enter()
                    .append('g')
                    .attr('class', d => d.isFocal ? 'node focal' : 'node')
                    .style('display', 'none')  // Hidden initially - start at macro
                    .call(d3.drag()
                        .on('start', (event, d) => this.dragStart(event, d))
                        .on('drag', (event, d) => this.dragging(event, d))
                        .on('end', (event, d) => this.dragEnd(event, d)))
                    .on('click', (event, d) => this.selectNode(d))
                    .on('dblclick', (event, d) => {
                        event.stopPropagation();
                        this.releaseNode(d);
                    })
                    .on('mouseenter', (event, d) => this.showTooltip(event, d))
                    .on('mouseleave', () => this.hideTooltip());

                this.nodeElements.append('circle')
                    .attr('class', 'node-circle')
                    .attr('r', d => d.radius)
                    .attr('stroke', d => this.getNodeStroke(d));

                this.nodeElements.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', d => d.radius + 15)
                    .text(d => this.truncateLabel(d.name));

                this.nodeElements.append('text')
                    .attr('class', 'node-type-indicator')
                    .attr('dy', 4)
                    .text(d => this.getTypeIcon(d.type));

                document.getElementById('entityCount').textContent = this.nodes.length;
                document.getElementById('connectionCount').textContent = this.links.length;

                // Start at macro level - will be rendered after HierarchyManager initializes
                setTimeout(() => {
                    if (HierarchyManager.data && HierarchyManager.currentLevel === 'macro') {
                        HierarchyManager.renderMacroView();
                    } else {
                        this.resetView();
                    }
                }, 600);
            },

            showError(message) {
                document.getElementById('loadingOverlay').innerHTML = `
                    <div style="text-align: center; padding: 2rem; max-width: 400px;">
                        <h3 style="color: #ef4444; margin-bottom: 1rem;">Failed to Load Data</h3>
                        <p style="color: var(--smoke);">${message}</p>
                    </div>
                `;
            },

            // Standard node radius - same for ALL nodes (no special treatment)
            STANDARD_NODE_RADIUS: 22,

            getRadius(type, connectionCount, isFocal = false) {
                // All nodes get the same size - no special treatment for focal entities
                return this.STANDARD_NODE_RADIUS;
            },

            // Check if an entity is the focal point of the current network
            isFocalEntity(entity) {
                // For Epstein Network, Jeffrey Epstein is the focal entity
                if (HierarchyManager.focusedNetwork === 'epstein-network') {
                    return entity.id === 'jeffrey-epstein' ||
                           entity.name?.toLowerCase() === 'jeffrey epstein';
                }
                // Add more network focal entities as needed
                return false;
            },

            getLinkColor(link) {
                // Color based on evidence type
                if (link.bidirectional || link.type === 'documented') {
                    return 'rgba(201, 162, 39, 0.6)'; // Gold - Documented
                }
                if (link.type === 'interpreted' || link.strength >= 50) {
                    return 'rgba(139, 111, 192, 0.5)'; // Purple - Referenced
                }
                return 'rgba(154, 154, 154, 0.4)'; // Gray - Associated
            },

            getLinkWidth(link) {
                // Width based on evidence type
                if (link.bidirectional || link.type === 'documented') {
                    return 2.5; // Documented - thickest
                }
                if (link.type === 'interpreted' || link.strength >= 50) {
                    return 1.5; // Referenced
                }
                return 1; // Associated - thinnest
            },

            getTypeIcon(type) {
                const icons = { person: 'PER', organization: 'ORG', case: 'CASE', location: 'LOC' };
                return icons[type] || '?';
            },

            truncateLabel(name) {
                return name.length > 22 ? name.substring(0, 20) + '...' : name;
            },

            tick() {
                this.linkElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                this.nodeElements
                    .attr('transform', d => `translate(${d.x}, ${d.y})`)
                    .classed('pinned', d => d.userPositioned);
            },

            dragStart(event, d) {
                // Gentle simulation for non-pinned nodes
                if (!event.active) this.simulation.alphaTarget(0.1).restart();
                d.fx = d.x;
                d.fy = d.y;
                d.userPositioned = true;
                d._dragging = true;
            },

            dragging(event, d) {
                d.fx = event.x;
                d.fy = event.y;

                // Push overlapping nodes with cascade effect
                this.pushNodesAway(d, event.x, event.y, d.radius + 50, new Set([d.id]));

                // Very gentle alpha for non-pinned nodes
                this.simulation.alpha(0.05);
            },

            // Recursively push nodes away, handling chain reactions
            pushNodesAway(sourceNode, fromX, fromY, minSeparation, alreadyPushed) {
                const nodesToPush = [];

                this.nodes.forEach(other => {
                    if (alreadyPushed.has(other.id)) return;

                    const dx = other.x - fromX;
                    const dy = other.y - fromY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = minSeparation + other.radius;

                    if (dist < minDist && dist > 0) {
                        // Calculate push direction (away from source)
                        const pushDist = minDist - dist + 5; // +5 for a little extra clearance
                        const pushX = (dx / dist) * pushDist;
                        const pushY = (dy / dist) * pushDist;

                        // Move the other node
                        other.x += pushX;
                        other.y += pushY;

                        // If it's pinned, update its pinned position too
                        if (other.userPositioned) {
                            other.fx = other.x;
                            other.fy = other.y;
                        }

                        // Track this node for cascade check
                        nodesToPush.push(other);
                        alreadyPushed.add(other.id);
                    }
                });

                // Cascade: each pushed node may need to push others
                nodesToPush.forEach(pushed => {
                    this.pushNodesAway(pushed, pushed.x, pushed.y, pushed.radius + 25, alreadyPushed);
                });
            },

            dragEnd(event, d) {
                if (!event.active) this.simulation.alphaTarget(0);
                d._dragging = false;
                // Node stays pinned where user placed it
            },

            // Double-click to release a node from its fixed position
            releaseNode(d) {
                d.fx = null;
                d.fy = null;
                d.userPositioned = false;
                // Gentle restart - node drifts back naturally without bouncing
                this.simulation.alpha(0.05).restart();
            },

            selectNode(node) {
                this.activeNode = node;
                // Track focused entity for document view
                HierarchyManager.focusedEntity = node;

                const connectedIds = new Set([node.id]);
                const connectionData = {};

                this.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === node.id) {
                        connectedIds.add(targetId);
                        connectionData[targetId] = link;
                    }
                    if (targetId === node.id) {
                        connectedIds.add(sourceId);
                        connectionData[sourceId] = link;
                    }
                });

                this.nodeElements
                    .classed('active', d => d.id === node.id)
                    .classed('highlighted', d => connectedIds.has(d.id) && d.id !== node.id)
                    .classed('dimmed', d => !connectedIds.has(d.id));

                this.linkElements
                    .classed('highlighted', d => {
                        const sid = typeof d.source === 'object' ? d.source.id : d.source;
                        const tid = typeof d.target === 'object' ? d.target.id : d.target;
                        return sid === node.id || tid === node.id;
                    })
                    .classed('dimmed', d => {
                        const sid = typeof d.source === 'object' ? d.source.id : d.source;
                        const tid = typeof d.target === 'object' ? d.target.id : d.target;
                        return sid !== node.id && tid !== node.id;
                    });

                this.showDetail(node, connectedIds, connectionData);
            },

            clearSelection() {
                this.activeNode = null;
                this.nodeElements.classed('active', false).classed('highlighted', false).classed('dimmed', false);
                this.linkElements.classed('highlighted', false).classed('dimmed', false);
                document.getElementById('detailPanel').classList.remove('active');
            },

            showDetail(node, connectedIds, connectionData) {
                const panel = document.getElementById('detailPanel');
                document.getElementById('detailType').textContent = node.type.toUpperCase();
                document.getElementById('detailType').style.color = this.colors[node.type];
                document.getElementById('detailTitle').textContent = node.name;
                document.getElementById('detailStatus').textContent = node.status || '';

                let html = '';

                if (node.summary) {
                    html += `<p>${node.summary}</p>`;
                }

                // Action buttons
                html += '<div class="action-buttons">';
                if (node.brief_file) {
                    html += `
                        <button class="action-btn" onclick="BriefViewer.open(Graph.activeNode)">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                                <polyline points="14,2 14,8 20,8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <line x1="10" y1="9" x2="8" y2="9"/>
                            </svg>
                            View Full Brief
                        </button>
                    `;
                }
                // Add document zoom button if entity has sources
                if (node.sources && node.sources.length > 0) {
                    html += `
                        <button class="action-btn" onclick="HierarchyManager.focusedEntity = Graph.activeNode; HierarchyManager.transitionToLevel('web')">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="11" cy="11" r="8"/>
                                <path d="m21 21-4.35-4.35"/>
                                <line x1="11" y1="8" x2="11" y2="14"/>
                                <line x1="8" y1="11" x2="14" y2="11"/>
                            </svg>
                            Zoom to Documents
                        </button>
                    `;
                }
                html += '</div>';

                // Connections
                const connections = this.nodes.filter(n => connectedIds.has(n.id) && n.id !== node.id);
                if (connections.length > 0) {
                    // Sort by evidence quality: documented > referenced > associated
                    connections.sort((a, b) => {
                        const linkA = connectionData[a.id];
                        const linkB = connectionData[b.id];
                        const orderA = linkA?.bidirectional ? 0 : (linkA?.type === 'documented' ? 1 : 2);
                        const orderB = linkB?.bidirectional ? 0 : (linkB?.type === 'documented' ? 1 : 2);
                        return orderA - orderB;
                    });

                    html += `<div class="detail-section">
                        <div class="connections-section-header">
                            <h4>Connections (${connections.length})</h4>
                            <button class="view-connections-brief-btn" onclick="ConnectionsPanel.openConnectionsBrief('${node.id}')">
                                üìã View Brief
                            </button>
                        </div>
                        <div class="progressive-web-controls">
                            <button class="show-all-btn" onclick="Graph.revealAllConnections()">
                                ‚äï Show All
                            </button>
                            <span id="revealedCount" class="revealed-count">0/${connections.length} revealed</span>
                        </div>
                        <ul class="connection-list">`;

                    connections.forEach(conn => {
                        const linkFromGraph = connectionData[conn.id];

                        // Look up rich connection data from the entity's connections array
                        let richConnectionData = null;
                        if (node.connections && Array.isArray(node.connections)) {
                            richConnectionData = node.connections.find(c =>
                                c.targetId === conn.id || c.target === conn.id
                            );
                        }

                        // Use rich data if available, fall back to link data
                        const summary = richConnectionData?.summary ||
                                       linkFromGraph?.summary ||
                                       linkFromGraph?.description ||
                                       'Connection documented in source materials.';
                        const sources = richConnectionData?.sources ||
                                       linkFromGraph?.sources ||
                                       [];

                        // Check if this connection is already revealed in the graph
                        const isRevealed = Graph.revealedNodes.has(conn.id);

                        html += `<li class="connection-item" data-entity="${conn.id}" data-target-entity="${conn.id}" data-revealed="${isRevealed}">
                            <div class="connection-header">
                                <span class="connection-expand-icon">‚ñ∂</span>
                                <div class="connection-header-info">
                                    <div class="connection-name">${conn.name}</div>
                                    <div class="connection-type" style="color: ${this.colors[conn.type]}">${conn.type}</div>
                                </div>
                            </div>
                            <div class="connection-dropdown" style="display: none;" data-loaded="false">
                                <div class="connection-summary">${summary}</div>
                                <div class="connection-sources">
                                    <div class="connection-sources-header">SOURCES:</div>
                                    <ul class="connection-sources-list">
                                        ${sources.length > 0 ? sources.map(s => `
                                            <li>
                                                <a class="connection-source-link" href="#" onclick="ConnectionsPanel.openSource('${s.id || s.ecf}'); return false;">
                                                    <span class="source-icon">üìÑ</span>
                                                    <span class="source-title">${s.title || s.description || 'Source Document'}</span>
                                                    ${s.date ? `<span class="source-date">${s.date}</span>` : ''}
                                                </a>
                                            </li>
                                        `).join('') : '<li class="no-sources">No source documents linked</li>'}
                                    </ul>
                                </div>
                                <button class="view-connection-brief-btn" onclick="ConnectionsPanel.openConnectionsBrief('${node.id}', '${conn.id}'); event.stopPropagation();">
                                    View Full Brief
                                </button>
                            </div>
                        </li>`;
                    });
                    html += '</ul></div>';
                }

                // Source documents
                if (node.sources && node.sources.length > 0) {
                    html += `<div class="detail-section">
                        <h4>Source Documents (${node.sources.length})</h4>
                        <ul class="source-list">`;

                    node.sources.slice(0, 10).forEach((source, i) => {
                        html += `<li class="source-item" data-source-index="${i}">
                            <span class="source-ecf">ECF ${source.ecf}</span>
                            <span class="source-desc"> - ${source.description}</span>
                        </li>`;
                    });

                    if (node.sources.length > 10) {
                        html += `<li class="source-item" style="color: var(--smoke); cursor: default;">
                            + ${node.sources.length - 10} more documents
                        </li>`;
                    }
                    html += '</ul></div>';
                }

                document.getElementById('detailContent').innerHTML = html;

                // Connection dropdown toggle handlers
                document.querySelectorAll('.connection-header').forEach(header => {
                    header.addEventListener('click', (e) => {
                        const item = header.closest('.connection-item');
                        if (!item) return;

                        const targetEntityId = item.dataset.targetEntity;

                        // PROGRESSIVE WEB: Reveal this node in the graph when clicked
                        if (targetEntityId && !this.revealedNodes.has(targetEntityId)) {
                            this.revealNode(targetEntityId);
                            // Update the data-revealed attribute
                            item.setAttribute('data-revealed', 'true');
                        }

                        // Toggle expanded state
                        const isExpanded = item.classList.contains('expanded');
                        const dropdown = item.querySelector('.connection-dropdown');

                        if (isExpanded) {
                            item.classList.remove('expanded');
                            dropdown.style.display = 'none';
                        } else {
                            item.classList.add('expanded');
                            dropdown.style.display = 'block';
                        }
                    });

                    // Double-click to navigate to entity
                    header.addEventListener('dblclick', (e) => {
                        const item = header.closest('.connection-item');
                        const targetNode = this.nodes.find(n => n.id === item.dataset.entity);
                        if (targetNode) this.selectNode(targetNode);
                    });
                });

                // Source document click handlers
                document.querySelectorAll('.source-item[data-source-index]').forEach(item => {
                    item.addEventListener('click', () => {
                        const idx = parseInt(item.dataset.sourceIndex);
                        if (node.sources && node.sources[idx]) {
                            PDFViewer.open(node.sources[idx]);
                        }
                    });
                });

                panel.classList.add('active');

                // Hide tooltip when detail panel opens (fixes mobile overlap)
                this.hideTooltip();
            },

            showTooltip(event, node) {
                // Don't show tooltip if detail panel is open (prevents overlap on mobile)
                if (document.getElementById('detailPanel').classList.contains('active')) {
                    return;
                }

                const tooltip = document.getElementById('tooltip');
                tooltip.querySelector('.tooltip-type').textContent = node.type;
                tooltip.querySelector('.tooltip-type').style.color = this.colors[node.type];
                tooltip.querySelector('.tooltip-name').textContent = node.name;

                let connectionText = `${node.connectionCount} connection${node.connectionCount !== 1 ? 's' : ''}`;
                if (node.userPositioned) {
                    connectionText += ' ¬∑ üìå Pinned (double-click to release)';
                }
                tooltip.querySelector('.tooltip-connections').textContent = connectionText;

                tooltip.style.left = (event.pageX + 15) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
                tooltip.classList.add('visible');
            },

            hideTooltip() {
                document.getElementById('tooltip').classList.remove('visible');
            },

            filterByType(type) {
                this.filterType = type;
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.toggle('active', item.dataset.type === type);
                });

                if (type === 'all') {
                    this.nodeElements.classed('dimmed', false);
                    this.linkElements.classed('dimmed', false);
                    return;
                }

                const matchingIds = new Set();
                this.nodes.forEach(node => {
                    if (node.type === type) matchingIds.add(node.id);
                });

                const expandedIds = new Set(matchingIds);
                this.links.forEach(link => {
                    const sid = typeof link.source === 'object' ? link.source.id : link.source;
                    const tid = typeof link.target === 'object' ? link.target.id : link.target;
                    if (matchingIds.has(sid)) expandedIds.add(tid);
                    if (matchingIds.has(tid)) expandedIds.add(sid);
                });

                this.nodeElements.classed('dimmed', d => !expandedIds.has(d.id));
                this.linkElements.classed('dimmed', d => {
                    const sid = typeof d.source === 'object' ? d.source.id : d.source;
                    const tid = typeof d.target === 'object' ? d.target.id : d.target;
                    return !expandedIds.has(sid) || !expandedIds.has(tid);
                });
            },

            filterNodes(query) {
                const q = query.toLowerCase().trim();
                if (!q) {
                    this.filterByType(this.filterType);
                    return;
                }

                const matchingIds = new Set();
                this.nodes.forEach(node => {
                    if ((node.name && node.name.toLowerCase().includes(q)) ||
                        (node.type && node.type.toLowerCase().includes(q)) ||
                        (node.status && node.status.toLowerCase().includes(q))) {
                        matchingIds.add(node.id);
                    }
                });

                const expandedIds = new Set(matchingIds);
                this.links.forEach(link => {
                    const sid = typeof link.source === 'object' ? link.source.id : link.source;
                    const tid = typeof link.target === 'object' ? link.target.id : link.target;
                    if (matchingIds.has(sid)) expandedIds.add(tid);
                    if (matchingIds.has(tid)) expandedIds.add(sid);
                });

                this.nodeElements.classed('dimmed', d => !expandedIds.has(d.id));
                this.linkElements.classed('dimmed', d => {
                    const sid = typeof d.source === 'object' ? d.source.id : d.source;
                    const tid = typeof d.target === 'object' ? d.target.id : d.target;
                    return !expandedIds.has(sid) || !expandedIds.has(tid);
                });
            },

            zoomIn() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 1.3);
            },

            zoomOut() {
                this.svg.transition().duration(300).call(this.zoom.scaleBy, 0.7);
            },

            resetView() {
                const width = window.innerWidth;
                const height = window.innerHeight;

                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                this.nodes.forEach(node => {
                    if (node.x < minX) minX = node.x;
                    if (node.x > maxX) maxX = node.x;
                    if (node.y < minY) minY = node.y;
                    if (node.y > maxY) maxY = node.y;
                });

                const padding = 100;
                const contentWidth = maxX - minX + padding * 2;
                const contentHeight = maxY - minY + padding * 2;
                const scale = Math.min(width / contentWidth, height / contentHeight, 1.5) * 0.85;
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                this.svg.transition().duration(500).call(
                    this.zoom.transform,
                    d3.zoomIdentity.translate(width / 2, height / 2).scale(scale).translate(-centerX, -centerY)
                );
                this.clearSelection();
            },

            // ============================================================
            // PROGRESSIVE WEB: Build your web through exploration
            // ============================================================

            // Apply progressive visibility - only show revealed nodes
            applyProgressiveVisibility() {
                // Hide all nodes except revealed ones
                this.nodeElements
                    .style('display', d => this.revealedNodes.has(d.id) ? null : 'none')
                    .style('opacity', d => this.revealedNodes.has(d.id) ? 1 : 0);

                // Hide all links except those between revealed nodes
                this.linkElements
                    .style('display', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        return this.revealedNodes.has(sourceId) && this.revealedNodes.has(targetId) ? null : 'none';
                    })
                    .style('opacity', d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        if (this.revealedNodes.has(sourceId) && this.revealedNodes.has(targetId)) {
                            return d.bidirectional || d.type === 'documented' ? 0.7 : 0.4;
                        }
                        return 0;
                    });
            },

            // Reveal a single node and its link to other revealed nodes
            revealNode(nodeId) {
                if (this.revealedNodes.has(nodeId)) return; // Already revealed

                this.revealedNodes.add(nodeId);

                // Animate the reveal
                const node = this.nodeElements.filter(d => d.id === nodeId);
                node
                    .style('display', null)
                    .style('opacity', 0)
                    .transition()
                    .duration(400)
                    .style('opacity', 1);

                // Show links connecting this node to other revealed nodes
                this.linkElements
                    .filter(d => {
                        const sourceId = typeof d.source === 'object' ? d.source.id : d.source;
                        const targetId = typeof d.target === 'object' ? d.target.id : d.target;
                        const involvesNewNode = sourceId === nodeId || targetId === nodeId;
                        const otherNodeRevealed = this.revealedNodes.has(sourceId) && this.revealedNodes.has(targetId);
                        return involvesNewNode && otherNodeRevealed;
                    })
                    .style('display', null)
                    .style('opacity', 0)
                    .transition()
                    .duration(400)
                    .style('opacity', d => d.bidirectional || d.type === 'documented' ? 0.7 : 0.4);

                // Update revealed count and visual indicators
                this.updateRevealedCount();
                this.updateRevealedIndicators();
            },

            // Reveal all connections to focal node at once
            revealAllConnections() {
                if (!this.focalNodeId) return;

                // Find all nodes connected to focal node
                const connectedIds = new Set();
                this.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === this.focalNodeId) connectedIds.add(targetId);
                    if (targetId === this.focalNodeId) connectedIds.add(sourceId);
                });

                // Reveal each with staggered animation
                let delay = 0;
                connectedIds.forEach(nodeId => {
                    if (!this.revealedNodes.has(nodeId)) {
                        setTimeout(() => this.revealNode(nodeId), delay);
                        delay += 50; // 50ms stagger between reveals
                    }
                });
            },

            // Center view on a specific node
            centerOnNode(node) {
                if (!node.x || !node.y) {
                    this.resetView();
                    return;
                }

                const transform = d3.zoomIdentity
                    .translate(window.innerWidth / 2, window.innerHeight / 2)
                    .scale(1.5)
                    .translate(-node.x, -node.y);

                this.svg.transition().duration(500)
                    .call(this.zoom.transform, transform);
            },

            // Update count display
            updateRevealedCount() {
                const countEl = document.getElementById('revealedCount');
                if (countEl) {
                    const total = this.getConnectedCount(this.focalNodeId);
                    const revealed = this.revealedNodes.size - 1; // Minus focal node
                    countEl.textContent = `${revealed}/${total} revealed`;
                }
            },

            // Update visual indicators for revealed connections in panel
            updateRevealedIndicators() {
                document.querySelectorAll('.connection-item').forEach(item => {
                    const targetId = item.dataset.targetEntity;
                    if (targetId && this.revealedNodes.has(targetId)) {
                        item.setAttribute('data-revealed', 'true');
                    }
                });
            },

            // Get count of connections to a node
            getConnectedCount(nodeId) {
                let count = 0;
                this.links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                    if (sourceId === nodeId || targetId === nodeId) count++;
                });
                return count;
            }
        };

        // ============================================================
        // CONNECTIONS PANEL - PHASE 4
        // ============================================================
        const ConnectionsPanel = {
            currentEntityId: null,

            // Toggle dropdown expansion for a connection item
            toggleDropdown(item) {
                const dropdown = item.querySelector('.connection-dropdown');
                const isExpanded = item.classList.contains('expanded');

                if (isExpanded) {
                    item.classList.remove('expanded');
                    dropdown.style.display = 'none';
                } else {
                    item.classList.add('expanded');
                    dropdown.style.display = 'block';
                }
            },

            // Open a source document
            openSource(sourceId) {
                // Try PDFViewer first
                if (typeof PDFViewer !== 'undefined' && PDFViewer.open) {
                    // Find source in current node's sources
                    const node = Graph.activeNode;
                    if (node && node.sources) {
                        const source = node.sources.find(s => s.id === sourceId || s.ecf === sourceId);
                        if (source) {
                            PDFViewer.open(source);
                            return;
                        }
                    }
                }
                console.warn('Source document not found:', sourceId);
            },

            // Open the full Connections Brief document
            // If targetEntityId is provided, opens pairwise brief (entity1_entity2.md)
            // Otherwise opens single-entity brief (entity_connections.md)
            openConnectionsBrief(entityId, targetEntityId = null) {
                if (!entityId) {
                    console.warn('No entity ID provided');
                    return;
                }

                // Normalize function for entity IDs
                const normalizeId = (id) => id
                    .toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '');

                // Get entity names for display
                const entity = Graph.nodes?.find(n => n.id === entityId);
                const entityName = entity?.name || entityId;
                const normalizedId = normalizeId(entityId);

                let pathsToTry = [];
                let displayTitle = entityName;

                if (targetEntityId) {
                    // Pairwise brief: use alphabetical ordering for consistent naming
                    const targetEntity = Graph.nodes?.find(n => n.id === targetEntityId);
                    const targetName = targetEntity?.name || targetEntityId;
                    const normalizedTargetId = normalizeId(targetEntityId);

                    // Sort alphabetically for consistent file naming
                    const [first, second] = [normalizedId, normalizedTargetId].sort();
                    const pairwiseFilename = `${first}_${second}.md`;

                    displayTitle = `${entityName} ‚Üî ${targetName}`;

                    // Try pairwise brief paths first, then fall back to single-entity
                    pathsToTry = [
                        `briefs/connections/${pairwiseFilename}`,
                        `/briefs/connections/${pairwiseFilename}`,
                        `/continuum/briefs/connections/${pairwiseFilename}`,
                        `../briefs/connections/${pairwiseFilename}`,
                        // Fallback to single-entity brief
                        `briefs/connections/${normalizedId}_connections.md`,
                        `/briefs/connections/${normalizedId}_connections.md`
                    ];
                } else {
                    // Single-entity connections brief
                    pathsToTry = [
                        `briefs/connections/${normalizedId}_connections.md`,
                        `/briefs/connections/${normalizedId}_connections.md`,
                        `/continuum/briefs/connections/${normalizedId}_connections.md`,
                        `../briefs/connections/${normalizedId}_connections.md`
                    ];
                }

                const tryFetch = (paths, index = 0) => {
                    if (index >= paths.length) {
                        // All paths failed
                        this.showBriefModal(displayTitle, `
                            <div style="text-align: center; padding: 2rem;">
                                <h3 style="color: var(--gold); margin-bottom: 1rem;">Connections Brief Not Available</h3>
                                <p style="color: var(--mist); line-height: 1.6;">
                                    The connections brief for <strong>${displayTitle}</strong> could not be loaded.
                                </p>
                                <p style="color: var(--smoke); font-size: 0.85rem; margin-top: 1rem;">
                                    Paths tried: ${paths.join(', ')}
                                </p>
                            </div>
                        `);
                        return;
                    }

                    fetch(paths[index])
                        .then(response => {
                            if (!response.ok) throw new Error('Not found');
                            return response.text();
                        })
                        .then(markdown => {
                            const html = typeof marked !== 'undefined' ? marked.parse(markdown) : `<pre>${markdown}</pre>`;
                            this.showBriefModal(displayTitle, html);
                        })
                        .catch(() => tryFetch(paths, index + 1));
                };

                tryFetch(pathsToTry);
            },

            // Display brief in modal
            showBriefModal(title, content) {
                // Remove existing modal if present
                const existing = document.querySelector('.connections-brief-modal');
                if (existing) existing.remove();

                const modal = document.createElement('div');
                modal.className = 'connections-brief-modal';
                modal.innerHTML = `
                    <div class="connections-brief-backdrop" onclick="this.parentElement.remove()"></div>
                    <div class="connections-brief-content">
                        <div class="connections-brief-header">
                            <h2>${title} ‚Äî Connections Brief</h2>
                            <button class="close-btn" onclick="this.closest('.connections-brief-modal').remove()">‚úï</button>
                        </div>
                        <div class="connections-brief-body brief-content">
                            ${content}
                        </div>
                    </div>
                `;

                document.body.appendChild(modal);

                // Linkify source references in the modal content
                const bodyEl = modal.querySelector('.connections-brief-body');
                if (bodyEl && BriefViewer.linkifySourceReferences) {
                    BriefViewer.linkifySourceReferences(bodyEl);
                }

                // Close on escape key
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', escHandler);
                    }
                };
                document.addEventListener('keydown', escHandler);
            }
        };

        // ============================================================
        // EVENT LISTENERS
        // ============================================================
        document.addEventListener('DOMContentLoaded', () => {
            // THEOLOGY LAYER - Handle entrance transition
            const theologyLayer = document.getElementById('theologyLayer');
            const theologyEnterButton = document.getElementById('theologyEnter');
            const hasSeenTheology = localStorage.getItem('continuum_theology_seen');

            // Check if user has already seen the theology layer
            if (hasSeenTheology === 'true') {
                // Skip theology layer for return visitors
                theologyLayer.classList.add('hidden');
                theologyLayer.style.display = 'none';
            } else {
                // First-time visitor: show theology layer
                // Hide main content until they click Enter
                document.querySelector('header').style.display = 'none';
                document.getElementById('graphContainer').style.display = 'none';
                document.getElementById('layerIndicator').style.display = 'none';
            }

            // Handle "Enter The Continuum" button click
            theologyEnterButton.addEventListener('click', (e) => {
                e.preventDefault();

                // Mark as seen
                localStorage.setItem('continuum_theology_seen', 'true');

                // Animate light expanding to fill screen (optional enhancement)
                theologyLayer.classList.add('hidden');

                // Show main content after transition
                setTimeout(() => {
                    theologyLayer.style.display = 'none';
                    document.querySelector('header').style.display = 'flex';
                    document.getElementById('graphContainer').style.display = 'block';
                    document.getElementById('layerIndicator').style.display = 'flex';

                    // Initialize the main application
                    Graph.init();
                    PDFViewer.init();
                    HierarchyManager.init();
                    EntitiesLayer.init();
                }, 1500);
            });

            // If returning visitor, initialize immediately
            if (hasSeenTheology === 'true') {
                Graph.init();
                PDFViewer.init();
                HierarchyManager.init();
                EntitiesLayer.init();
            }

            // Briefly show zoom hint on load (only for returning visitors)
            const zoomHint = document.getElementById('zoomHint');
            if (zoomHint && hasSeenTheology === 'true') {
                setTimeout(() => {
                    zoomHint.classList.add('visible');
                    setTimeout(() => {
                        zoomHint.classList.remove('visible');
                    }, 5000);
                }, 2000);
            }

            document.getElementById('searchInput').addEventListener('input', (e) => {
                Graph.filterNodes(e.target.value);
            });

            // Layer indicator (breadcrumb) click handlers
            document.querySelectorAll('.layer-crumb').forEach(crumb => {
                crumb.addEventListener('click', () => {
                    const level = crumb.dataset.level;
                    if (level === 'theology') {
                        // Special handling for theology breadcrumb - return to theology layer
                        localStorage.removeItem('continuum_theology_seen');
                        location.reload();
                    } else if (level) {
                        HierarchyManager.navigateToLevel(level);
                    }
                });
            });

            // Side level indicator click handlers
            document.querySelectorAll('#levelIndicator .level-node').forEach(node => {
                node.addEventListener('click', () => {
                    const level = node.dataset.level;
                    if (level && !node.classList.contains('disabled')) {
                        // Don't navigate to web layer without a focused entity
                        if (level === 'web' && !HierarchyManager.focusedEntity) {
                            return;
                        }
                        HierarchyManager.navigateToLevel(level);
                    }
                });
            });

            document.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    document.getElementById('searchInput').value = '';
                    Graph.filterByType(item.dataset.type);
                });
            });

            document.getElementById('closeDetail').addEventListener('click', () => Graph.clearSelection());
            document.getElementById('zoomIn').addEventListener('click', () => Graph.zoomIn());
            document.getElementById('zoomOut').addEventListener('click', () => Graph.zoomOut());
            document.getElementById('resetView').addEventListener('click', () => Graph.resetView());

            // Brief viewer
            document.getElementById('closeBrief').addEventListener('click', () => BriefViewer.close());
            document.getElementById('briefPrev').addEventListener('click', () => BriefViewer.prev());
            document.getElementById('briefNext').addEventListener('click', () => BriefViewer.next());

            // PDF viewer
            document.getElementById('closePdf').addEventListener('click', () => PDFViewer.close());

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                // Close modals or navigate hierarchy on Escape
                if (e.key === 'Escape') {
                    if (document.getElementById('pdfViewer').classList.contains('active')) {
                        PDFViewer.close();
                    } else if (document.getElementById('briefViewer').classList.contains('active')) {
                        BriefViewer.close();
                    } else if (HierarchyManager.currentLevel === 'web' || HierarchyManager.currentLevel === 'documents') {
                        // Exit web/document view back to entities
                        HierarchyManager.transitionToLevel('entities');
                    } else if (HierarchyManager.currentLevel === 'entities') {
                        // Exit entities view back to macro
                        HierarchyManager.transitionToLevel('macro');
                    } else if (HierarchyManager.currentLevel === 'macro') {
                        // Already at top level - do nothing or clear selection
                        Graph.clearSelection();
                    } else {
                        Graph.clearSelection();
                        document.getElementById('searchInput').value = '';
                        Graph.filterByType('all');
                    }
                }

                // PDF navigation
                if (document.getElementById('pdfViewer').classList.contains('active')) {
                    if (e.key === 'ArrowLeft') PDFViewer.prevPage();
                    if (e.key === 'ArrowRight') PDFViewer.nextPage();
                    if (e.key === '+' || e.key === '=') PDFViewer.zoomIn();
                    if (e.key === '-') PDFViewer.zoomOut();
                    return; // Don't process other shortcuts when PDF viewer is open
                }

                // Brief navigation
                if (document.getElementById('briefViewer').classList.contains('active')) {
                    if (e.key === 'ArrowLeft') BriefViewer.prev();
                    if (e.key === 'ArrowRight') BriefViewer.next();
                }

                // Hierarchy level navigation (0=theology, 1-3 keys for 3-level structure)
                if (!document.getElementById('briefViewer').classList.contains('active') &&
                    !document.getElementById('pdfViewer').classList.contains('active')) {
                    // Ctrl/Cmd + 0 = Return to Theology Layer
                    if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        localStorage.removeItem('continuum_theology_seen');
                        location.reload();
                    }
                    if (e.key === '1') HierarchyManager.navigateToLevel('macro');
                    if (e.key === '2') HierarchyManager.navigateToLevel('entities');
                    if (e.key === '3' && HierarchyManager.focusedEntity) {
                        HierarchyManager.transitionToLevel('web');
                    }
                }

                // Graph zoom (when not in modals)
                if (!document.getElementById('briefViewer').classList.contains('active') &&
                    !document.getElementById('pdfViewer').classList.contains('active')) {
                    if (e.key === '+' || e.key === '=') Graph.zoomIn();
                    if (e.key === '-') Graph.zoomOut();
                    if (e.key === '0') Graph.resetView();

                    // Arrow key level navigation (up/right = go deeper, down/left = go shallower)
                    const levels = ['macro', 'entities', 'web'];
                    const currentIndex = levels.indexOf(HierarchyManager.currentLevel);

                    if (e.key === 'ArrowUp' || e.key === 'ArrowRight') {
                        // Go deeper in hierarchy
                        if (currentIndex < levels.length - 1) {
                            const nextLevel = levels[currentIndex + 1];
                            // Don't go to web without a focused entity
                            if (nextLevel === 'web' && !HierarchyManager.focusedEntity) {
                                return;
                            }
                            HierarchyManager.navigateToLevel(nextLevel);
                        }
                    }

                    if (e.key === 'ArrowDown' || e.key === 'ArrowLeft') {
                        // Go shallower in hierarchy
                        if (currentIndex > 0) {
                            HierarchyManager.navigateToLevel(levels[currentIndex - 1]);
                        }
                    }
                }
            });

            window.addEventListener('resize', () => {
                if (Graph.simulation) {
                    Graph.simulation
                        .force('center', d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
                        .alpha(0.3)
                        .restart();
                }
            });
        });
    </script>
</body>
</html>
